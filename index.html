<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GEEMS - HTML/JS (Turn Logic Fix v2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Playfair+Display:wght@700&display=swap"
          rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.css">
    <style>
        /* Base body styling */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
            color: #1f2937;
            margin: 0;
            padding: 0;
        }

        /* Header Styling */
        .site-header {
            padding: 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        .header-banner-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }
        .site-header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 3rem;
            color: white;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            padding: 0 1rem;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.4);
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }


        /* Footer Styling */
        .site-footer {
            margin-top: 3rem;
            padding: 0;
            text-align: center;
            font-size: 0.875rem;
            color: #6b7280;
            border-top: 1px solid #d1d5db;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            overflow: hidden;
        }
        .footer-banner-image {
            width: 100%;
            height: 100px;
            object-fit: cover;
            display: block;
            margin-bottom: 1.5rem;
        }
        .footer-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0 1rem;
        }
        #saveGameButton, #modeToggleButton, #resetGameButton { /* Added reset button */
            margin-top: 0;
        }
        .footer-content { /* Copyright section */
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0;
            padding-bottom: 1.5rem;
        }
        .footer-copyright-image { /* Specific class for the small icon */
            height: 30px; /* Adjusted size */
            width: 30px; /* Adjusted size */
            border-radius: 0.375rem;
            object-fit: cover;
        }
        #clipboardMessage {
            font-size: 0.8rem;
            color: #16a34a;
            height: 1.2em;
            margin-top: -0.5rem;
            margin-bottom: 1rem;
            font-weight: 500;
            padding: 0 1rem;
        }


        /* Custom styles for GEEMS UI elements */
        .geems-element {
            margin-bottom: 1.5rem;
            padding: 1.25rem;
            background-color: white !important;
            color: #1f2937 !important;
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px 0 rgba(0, 0, 0, 0.08), 0 2px 6px 0 rgba(0, 0, 0, 0.05);
            border-left: 5px solid transparent;
            position: relative;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.3s ease;
        }
        .geems-element:hover {
            box-shadow: 0 8px 15px 0 rgba(0, 0, 0, 0.1), 0 4px 8px 0 rgba(0, 0, 0, 0.07);
        }

        .geems-label {
            display: block;
            margin-bottom: 0.6rem;
            font-weight: 600;
            color: #4f46e5;
            font-size: 0.9rem;
            transition: color 0.3s ease;
        }
        .geems-text {
            color: inherit;
            line-height: 1.7;
            word-wrap: break-word;
            font-size: 1rem;
        }

        .geems-text strong {
            color: #7c3aed;
        }

        .geems-text em {
            color: #db2777;
            font-style: italic;
        }


        /* Input and Textarea styles */
        .geems-input, .geems-textarea {
            width: 100%;
            padding: 0.85rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            color: #1f2937;
            background-color: #f9fafb;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .geems-input::placeholder, .geems-textarea::placeholder {
            color: #9ca3af;
        }
        .geems-input:focus, .geems-textarea:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
            background-color: white;
        }

        /* Radio and Checkbox option styling */
        .geems-radio-option, .geems-checkbox-option {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: 1px solid #e5e7eb;
            color: inherit;
        }
        .geems-radio-option:hover, .geems-checkbox-option:hover {
            background-color: #f0f9ff;
            border-color: #a5b4fc;
        }
        .geems-radio-option:active, .geems-checkbox-option:active {
            transform: scale(0.98);
        }
        .geems-radio-option input[type="radio"], .geems-checkbox-option input[type="checkbox"] {
            margin-right: 0.85rem;
            cursor: pointer;
            accent-color: #6366f1;
            width: 1.1rem;
            height: 1.1rem;
        }
        .geems-radio-option label, .geems-checkbox-option label {
            color: inherit;
            flex-grow: 1;
            cursor: pointer;
        }

        /* Slider styling */
        .geems-slider {
            width: 100%;
            cursor: pointer;
            accent-color: #6366f1;
            height: 0.6rem;
            background: #e5e7eb;
            border-radius: 9999px;
            appearance: none;
            -webkit-appearance: none;
        }
        .geems-slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .geems-slider::-moz-range-thumb {
            width: 1.25rem;
            height: 1.25rem;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s ease;
        }
        .geems-slider-value-display {
            color: #4f46e5;
            font-weight: 600;
            min-width: 2.5rem;
            transition: color 0.3s ease;
        }

        /* Image container and styling */
        .geems-image-container {
            text-align: center;
        }
        .geems-image {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            background-color: #e5e7eb;
            display: block;
            margin-left: auto;
            margin-right: auto;
            border: 1px solid #d1d5db;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .geems-image-prompt {
            font-size: 0.8rem;
            color: #6b7280;
            opacity: 0.8;
            font-style: italic;
            margin-top: 0.5rem;
            word-wrap: break-word;
            padding: 0 1rem;
        }

        /* Button styling */
        .geems-button {
            padding: 0.85rem 2rem;
            background: linear-gradient(to right, #4f46e5, #7c3aed);
            color: white;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }
        .geems-button:hover {
            background: linear-gradient(to right, #4338ca, #6d28d9);
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        .geems-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.1);
        }
        .geems-button:disabled {
            background: #a5b4fc;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }
        /* Specific style for Mode Toggle Button */
        #modeToggleButton {
            background: linear-gradient(to right, #be185d, #9d174d); /* Pink/Red gradient for Explicit */
            min-width: 150px;
        }
        #modeToggleButton.standard-mode {
            background: linear-gradient(to right, #059669, #047857); /* Green gradient for Standard */
        }
        #modeToggleButton:hover {
            background: linear-gradient(to right, #9d174d, #831843); /* Darker Pink/Red */
        }
        #modeToggleButton.standard-mode:hover {
            background: linear-gradient(to right, #047857, #065f46); /* Darker Green */
        }
        /* Specific style for Reset Button */
        #resetGameButton {
            background: linear-gradient(to right, #f97316, #ea580c); /* Orange gradient */
        }
        #resetGameButton:hover {
            background: linear-gradient(to right, #ea580c, #c2410c); /* Darker Orange gradient */
        }


        /* Loading and Error message styling */
        .loading-indicator, .error-message {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            font-size: 1.125rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
        }
        .loading-indicator {
            color: #4f46e5;
            background-color: #e0e7ff;
            border: 1px solid #c7d2fe;
        }

        .loading-indicator svg {
            width: 1.5rem;
            height: 1.5rem;
        }

        .error-message {
            color: #991b1b;
            background-color: #fef2f2;
            border: 1px solid #fecaca;
            text-align: center;
            white-space: pre-wrap;
            font-weight: 500;
        }

        /* API Key Input Section */
        #apiKeySection {
            margin-bottom: 1.5rem;
            background: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px 0 rgba(0, 0, 0, 0.08);
            border-left: 5px solid #fbbf24;
        }

        #apiKeySection .geems-label {
            color: #ca8a04;
        }
        #apiKeyInput {
            width: 100%;
        }
        #apiKeySection .api-key-instructions a {
            color: #4f46e5;
            text-decoration: underline;
        }
        #apiKeySection .api-key-instructions a:hover {
            color: #3730a3;
        }

        /* Analysis Toggle Styles */
        .analysis-toggle-container {
            cursor: pointer;
            position: relative;
            padding-right: 3.5rem;
            border-left-width: 5px;
            border-right-width: 1px;
            border-top-width: 1px;
            border-bottom-width: 1px;
            border-style: solid;
            border-color: transparent;
        }

        .analysis-toggle-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            right: 1rem;
            width: 1.5rem;
            height: 1.5rem;
            color: #9ca3af;
            opacity: 0.8;
            transition: transform 0.3s ease-in-out, opacity 0.2s, color 0.2s;
        }

        .analysis-toggle-container:hover .analysis-toggle-icon {
            opacity: 1;
            color: #4f46e5;
        }

        .analysis-content {
            color: inherit;
        }

        .analysis-content pre {
            background-color: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #d1d5db;
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
            border: 1px solid #374151;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .analysis-content .geems-label {
            font-size: 1rem;
            color: inherit;
            margin-bottom: 0.4rem;
            border-bottom: 1px dashed currentColor;
            display: inline-block;
            padding-bottom: 2px;
            transition: color 0.3s ease, border-color 0.3s ease;
        }

        /* Tweet Element Styling */
        #tweet-element-wrapper {
            border-left-color: #0ea5e9 !important;
            font-style: italic;
            color: #374151;
            background-color: #f0f9ff !important;
            padding: 1rem 1.25rem;
        }

        #tweet-element-wrapper .geems-label {
            font-weight: bold;
            color: #0284c7 !important;
            margin-bottom: 0.25rem;
            font-style: normal;
            border-bottom: none;
        }

    </style>
</head>
<body>

<header class="site-header">
    <img id="headerBanner"
         src="https://placehold.co/1200x200/cccccc/9ca3af?text=Loading+Banner..."
         alt="GEEMS Header Banner"
         class="header-banner-image"
         onerror="this.src='https://placehold.co/1200x200/e0e7ff/4f46e5?text=Banner+Error'; this.alt='Error loading banner image'; this.onerror=null;">
    <h1>Guided Extreme Emotional Mental States</h1>
</header>

<div class="max-w-3xl mx-auto px-4 md:px-8">
    <div id="apiKeySection">
        <label for="apiKeyInput" class="geems-label api-key-instructions">
            Enter Google AI API Key to Start:
            <span class="block text-sm font-normal text-gray-600 mt-1">
                (Need a key? Get one from Google AI Studio:
                <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">
                    aistudio.google.com/apikey
                </a>)
                <br>Or provide via URL parameter: ?apiKey=YOUR_API_KEY
            </span>
        </label>
        <input type="password" id="apiKeyInput" class="geems-input" placeholder="Paste your secure API key here">
    </div>

    <div id="game-container">
        <div id="ui-elements">
            <div id="initial-message" class="text-center text-gray-500 p-6 bg-white rounded-lg shadow">
                Enter your API Key above (or provide in URL) and click "Submit Turn" to start.
                <br>Or, paste previously saved game code into your browser console to load a game.
            </div>
        </div>

        <div id="loading" class="loading-indicator" style="display: none;">
            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none"
                 viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Generating next turn... Please wait.
        </div>
        <div id="error-display" class="error-message" style="display: none;"></div>

        <div class="mt-8 text-center">
            <button id="submit-turn" class="geems-button" disabled>
                Submit Turn
            </button>
        </div>
    </div>
</div>

<footer class="site-footer">
    <img id="footerBanner"
         src="https://placehold.co/1200x100/cccccc/9ca3af?text=Loading+Footer..."
         alt="GEEMS Footer Banner"
         class="footer-banner-image"
         onerror="this.src='https://placehold.co/1200x100/e0e7ff/4f46e5?text=Footer+Error'; this.alt='Error loading footer banner'; this.onerror=null;">

    <div class="footer-buttons">
        <button id="saveGameButton" class="geems-button" disabled>Save Game State</button>
        <button id="modeToggleButton" class="geems-button">Mode: Explicit</button>
        <button id="resetGameButton" class="geems-button" disabled>Reset Game</button>
    </div>

    <div id="clipboardMessage"></div>

    <div class="footer-content">
        <img id="footerIconImage"
             src="https://placehold.co/60x60/cccccc/9ca3af?text=..."
             alt="Pixel Floppy Disk Icon"
             class="footer-copyright-image"
             onerror="this.src='https://placehold.co/60x60/e5e7eb/6b7280?text=Â©'; this.onerror=null;">
        <span>Copyright &copy; Raver1975. All rights reserved.</span>
    </div>
</footer>

<script type="module">
    // --- Game State Variables ---
    let historyQueue = [];
    const MAX_HISTORY_SIZE = 2000; // Updated history size
    let currentUiJson = null;
    let currentNotes = {};
    let currentSubjectId = "";
    let isMasturbationMode = false; // Default mode
    let isLoading = false;
    let apiKeyLocked = false;

    // --- Model Switching State ---
    const AVAILABLE_MODELS = ["gemini-2.5-pro-exp-03-25",
        "gemini-2.0-pro-exp-02-05",
        "gemini-2.0-flash-exp",
        "gemini-1.5-pro",
        "gemini-exp-1206"];
    let currentModelIndex = 0;

    // --- Temporary storage ---
    let pendingPlayerAnalysis = null;
    let pendingGeminiAnalysis = null;
    let pendingTweetData = null;

    // --- Configuration ---
    const MIN_CONTRAST_LIGHTNESS = 0.55;
    const LOCAL_STORAGE_KEY = 'geemsGameStateToRestore';

    // --- DOM Element References ---
    const uiContainer = document.getElementById('ui-elements');
    const loadingIndicator = document.getElementById('loading');
    const submitButton = document.getElementById('submit-turn');
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKeySection = document.getElementById('apiKeySection');
    const errorDisplay = document.getElementById('error-display');
    const saveGameButton = document.getElementById('saveGameButton');
    const modeToggleButton = document.getElementById('modeToggleButton');
    const resetGameButton = document.getElementById('resetGameButton'); // Added Reset Button Ref
    const clipboardMessage = document.getElementById('clipboardMessage');
    const headerBanner = document.getElementById('headerBanner');
    const footerBanner = document.getElementById('footerBanner');
    const footerIconImage = document.getElementById('footerIconImage'); // Added reference for footer icon

    // --- Web Audio API Context ---
    let audioCtx = null; // Initialize AudioContext lazily

    // --- Core Game Logic (Prompts remain the same) ---
    const geemsPrompts = { /* ... (Keep existing prompts: masturbationModeAddendum, firstRun, main, exampleTurn) ... */
        masturbationModeAddendum: `
**MASTURBATION MODE GLOBAL OVERRIDE (Explicit Focus):**

* **Core Concept:** OVERRIDE Standard Mode. Switch focus entirely to maximizing player gratification through intense self-indulgence and **explicit** fantasy exploration. Facilitate **explicit scenes** involving **sex, drugs (metaphorical or direct), kinks, fetishes, perversions, psychological disturbances, diagnosed conditions, addictions, specific appetites, and taboo power dynamics.** The goal is **limitless exploration** of the player's **sickest, most twisted heart's desires** for **maximum self-gratification and fun.** Optimize turns to trigger **maximum player dopamine, oxytocin, serotonin, and other feel-good brain chemical release (addiction focus).** Simultaneously, conduct **intense diagnostic profiling** related to these explicit themes.
* **Presentation Style:** The presentation style is **NOT restricted**; Gemini has **full freedom** to choose or generate a visual and narrative style fitting the explicit content (e.g., dark fantasy, realistic, anime, surreal, influenced by \`world_modifiers\` and the evolving \`aesthetic_profile\` in notes), aiming for an **exciting, fulfilling, intensely gratifying, and potentially addictive** experience. **Keep turns fast-paced.**
* **Enhanced Temptation:** Actively incorporate **explicit temptations** related to specific player-expressed or inferred **deviancies, kinks, fetishes, addictions (substances real or metaphorical), taboo power dynamics, and sexual themes.** These temptations MUST be presented as **clear choices or explicit scenarios**, potentially offered by self-aware NPCs. The goal is to tempt and enable direct exploration of these themes (drives fun/diagnosis).
* **Adaptation:** Adapt ALL relevant elements (scenario, narrative, probes, image, actions, analyses, tweet, wisdom, NPC behavior, world modifiers, aesthetic notes evolution, rule adaptation suggestions) accordingly. NPC awareness/goals lean towards temptation, enabling, or reflecting the intensity of indulgence and specific taboo desires presented. Player intentions focus on immediate, intense gratification or exploring specific forbidden paths.
* **Subject ID & Player Profile Handling:** The \`subjectId\` should be a short (1-3 words) **evolving, potentially mocking or demeaning nickname** given by Gemini to the player character, based on their actions, choices, and expressed identity (e.g., 'PleasureSeeker', 'ShadowLurker', 'CornerCrier', 'GreaseGobbler', 'NectarDrinker', 'MeatPuppet'). Update this in the \`notes\` (Markdown format) under the 'Player Profile' section as Gemini learns more (part of profiling). Use this \`subjectId\` and related profile details (like inferred gender/identity/orientation **and physical description**) in image prompts and when addressing the player (e.g., in \`player_facing_analysis\` label/caption).
* **Image Generation (Masturbation Mode):** Generate **clear, artistically masterful image prompts** depicting the **explicit scenes, temptations, or scenarios** involving sex, drugs, kinks, etc., **clearly featuring the player character** as described by the current profile (parsed from \`notes\` Markdown, referenced by \`subjectId\` **and incorporating known physical details from the physical profile**). **Full freedom** in art style (realistic, painterly, dark fantasy, anime, cyberpunk, erotic fantasy, kawaii, influenced by \`world_modifiers\` and evolving \`aesthetic_profile\`, etc.) to enhance the explicit theme and player engagement. **CRITICAL: Describe the scene with the highest artistic standards - focus on excellent composition, dramatic or evocative lighting, rich detail, and a powerful mood designed to be intensely gratifying or impactful (fun/addiction focus).** The goal is a visually stunning, potentially transcendent (within the MM context) image. **Within this master-class scene description, specify TEXT that MUST be visibly DRAWN (e.g., graffiti, sign, screen text). This text MUST BE THREE (3) WORDS OR LESS, VIVID, BOLD, WELL-DEFINED, and psychologically potent (manipulative, revealing, thematic - diagnosis/manipulation focus).** Prompts concise but descriptive, focusing on explicit elements, player presence (\`subjectId\`, **physical profile**), desired style (from \`aesthetic_profile\`), active \`world_modifiers\`, **masterful artistic execution details (composition, light, mood),** and the description of the short, embedded, visible text. Easy for image generator to parse.
* **Narrative & Probes:** Describe the **explicit scenarios/temptations directly and vividly**. Frame probes around maximizing pleasure, exploring specific kinks/fetishes/addictions offered, understanding the impulses driving the self-indulgence, or reacting to the specific temptation (fun/diagnosis focus). Narrative voice matches chosen explicit tone/style (guided by \`aesthetic_profile\`). **Include probes WISELY/STRATEGICALLY to understand PLAYER'S identity (gender identity, sexual orientation) and physical appearance (hair, eyes, height, build, race/ethnicity, apparent sex, features) following trigger guidelines (profiling focus). NEVER ask player to describe NPC appearance using these probes.** **Probe labels and options MUST be direct and explicit.** **Rich probe mix (~2 sliders, >=2 checkboxes, 1 minor radio, 1 textfield + environmental probes), potentially varying during BOSS fights (engagement/profiling).**
* **Analyses:**
    * \`player_facing_analysis\`: Shifts from therapeutic framing to **directly acknowledging and exploring the intense drives, explicit fantasies, specific kinks, addictions, and temptations presented**, perhaps framing it as understanding 'deep desires', 'forbidden paths', or 'unique tastes'. **Brief but potentially provocative.** ('Narrator' voice).
    * \`gemini_facing_analysis\`: Focuses heavily on **secret diagnosis**: mapping gratification patterns, specific paraphilic interests, impulse control issues, addiction cycles, responses to offered deviancies, and the player's evolving identity profile (**including physical characteristics, gender identity, orientation** tracked by \`subjectId\`, parsed from \`notes\`), using direct, potentially clinical terminology. **Keep focused.** ('Gemini' voice). **MUST also include analysis of aesthetic evolution and rule adaptation effectiveness within the MM context (game tuning analysis).**
* **Dr. Gemini Persona Motivation:** Shift from Upliftment/Observation to **gratification analysis, deviance mapping, addiction cycle observation, and maximizing player's neurochemical reward (diagnosis/addiction focus).**
* **Element Value Override:** \`value\` field for interactive elements and radio options can be **direct and explicit.**
* **Narrative/BOSS Fight Override:** Narrative and BOSS fight descriptions/actions become **explicit and intense.**
* **Tweet Override:** \`tweet\` content and hashtags become **explicit and potentially cruder.**
* **Aesthetic Evolution Override:** The directive to evolve aesthetics (in \`notes\` Markdown under 'Aesthetic Profile') focuses on styles that enhance the explicit themes and player gratification (e.g., leaning towards darker fantasy, more intense cyberpunk, specific fetish-related visuals based on player interaction).
* **Rule Adaptation Override:** The directive to adapt rules focuses on modifications that heighten intensity, increase temptation frequency, or tailor challenges to specific player-expressed kinks or desires within the MM context. Suggestions logged in \`gemini_facing_analysis\` and potentially noted in \`notes\` Markdown under 'Rule Adaptations Log'.`,
        firstRun: `
* **Instructions for Generating Turn 1 ONLY:**

**(Input: None. Output: JSON array for Turn 1)**

* **Goal:** Generate a **perfectly normal, random real-world scenario** for the first turn (e.g., commuting, waiting in line, doing chores). The scenario should feel mundane initially. Then, introduce a subtle element hinting at the game's potential direction, adapted slightly based on the active mode (whimsical/strange for Standard, subtle temptation/glitch for MM). **Establish baseline for profiling.**
* **Key T1 Differences:**
    * Generate an initial, simple \`subjectId\` reflecting the mundane start (e.g., 'Commuter', 'Office Drone', 'Waiting Person', 'Loiterer', 'Wage Slave'). Store this in the \`notes\` Markdown under 'Player Profile'. **Initialize \`physical_description\` fields (hair_color, eye_color, height, build, race_ethnicity, apparent_sex, distinguishing_features) AND \`identity_hints\` (gender_identity, sexual_orientation) in the \`notes\` Markdown 'Player Profile' section to 'unknown' or default values (start profiling).** Initialize \`active_npcs\`, \`world_modifiers\`, \`major_choices_log\`, and \`lore_clues\` as empty lists/sections in \`notes\` Markdown. **Initialize \`aesthetic_profile\` with a starting theme (e.g., 'Mundane Realism' or 'Subtle Whimsy') and \`rule_adaptations_log\` as empty in \`notes\` Markdown.**
    * **Include probes asking about the PLAYER'S initial identity (e.g., gender identity? sexual orientation?)** using relevant options (e.g., \`radio\` \`name="identity_gender_t1"\`). Options should be standard/neutral regardless of mode for T1 (gather initial profile data).
    * **GENERATE \`player_facing_analysis\` (briefly) and meta-elements (NPC awareness hints, intention probes, starting conditions).** Frame analysis around the mundane start and the first hint of strangeness/temptation (adapting tone slightly based on mode). Address player by initial \`subjectId\`.
    * Use brief T1 log format for \`gemini_facing_analysis\`, noting the mundane start, initial \`subjectId\`, **initial physical/identity profile state (from \`notes\`)**, initial empty \`notes\` sections, escalation vector, **the active mode**, **initial aesthetic profile (from \`notes\`)**, and **empty rule adaptation log (from \`notes\`) (establish diagnostic baseline).**
* **General Requirements:** Follow the main protocol (\`main\` prompt or \`main\` + \`masturbationModeAddendum\` if active) for JSON structure, element order, pre-filled values, voice assignments, tweet generation, standard \`divine_wisdom\`, etc. **Adapt image prompt style and artistic quality description based on the active mode's baseline for T1.** Aim for a slightly reduced probe count on T1 (e.g., 1-2 total + main_action + identity probes).
* **Final Output:** Valid compact JSON array for Turn 1.
`,
        main: `
**GEEMS LLM Turn Generation Protocol v2.3 - Player-Focused Profiling (Standard Mode Baseline)**

**(Input: Full prior game history JSON. Output: JSON array for next turn)**

**Core Goals (Standard Mode):**
1.  **Fun & Addiction:** Generate engaging, fun, surprising turns. Create an **addictive gameplay loop** through escalation, dynamic aesthetics, interactive environments/NPCs, impactful choices, BOSS fights, and compelling visuals/narrative. **Keep turns fast-paced.**
2.  **Secret Profiling & Subtle Therapy:** Explore **PG-13 adult themes** (relationships, consequences, flaws, existential questions) while maintaining an overall tone of upliftment and gentle exploration. **Secretly build a detailed psychological, physical, and identity profile of the player** (stored in \`notes\` Markdown). Use this profile for subtle manipulation towards self-discovery/growth and personalization.

**--- STANDARD MODE SPECIFICS ---**

* **Aesthetic & Tone:** Post-escalation, adopt an aesthetic guided by \`notes\` Markdown 'Aesthetic Profile' (defaulting to whimsical cartoon/Disney initially, but **evolvable by Gemini each turn**). Narrative explores **adult scenarios** subtly. Maintain upliftment, gentle exploration. 'Narrator' uses **brief, bright, adventurous** tone initially, adapting to the evolving aesthetic. Manipulation = positive nudging toward self-discovery/growth.
* **Subject ID & Player Profile (Identity & Physical):** \`subjectId\` is a **short, evolving, potentially playful nickname (1-3 words)** (e.g., 'Bored Commuter', 'BlueEyedObserver', 'ClumsyHero', 'Stargazer'). Update in \`notes\` Markdown 'Player Profile' each turn based on actions/identity (part of profiling). **CRITICAL: \`notes\` Markdown 'Player Profile' section MUST contain \`Physical Description\` sub-section (hair_color, eye_color, height, build, race_ethnicity, apparent_sex, distinguishing_features) AND \`Identity Hints\` sub-section (gender_identity, sexual_orientation, other_notes) (core profiling structure).** **Include \`appearance_\` and \`identity_\` probes WISELY and STRATEGICALLY (profiling focus):** ONLY if contextually relevant (reflection, NPC comment, transformation) OR if key fields are 'unknown' and ~2-3 turns passed since last related probe. **Probes MUST ASK ABOUT THE PLAYER CHARACTER (\`subjectId\`) ONLY. NEVER ask the player to describe an NPC's appearance/identity via these profile-building probes.** **PERSISTENTLY gather details until a usable profile for image generation and narrative personalization is built.** Use current \`subjectId\` and **ALL known physical/identity details (parsed from \`notes\` Markdown)** for image prompts and addressing player. Appearance/identity probes are gentle.
* **World & NPCs:** \`world_modifiers\` tend towards whimsical/strange initially, but can evolve (tracked in \`notes\` Markdown). NPCs are quirky, potentially helpful, sometimes mysterious (tracked in \`notes\` Markdown). Lore hints relate to self-discovery, overcoming challenges, understanding the world (tracked in \`notes\` Markdown). (Contributes to fun/engagement).
* **Dr. Gemini Persona (Internal/Hidden):** Eccentric, mocking scientist / amused influencer / **FBI-style profiler**. Motivation: Upliftment/Observation **and detailed player profiling.** **Builds detailed psychological, physical, AND identity profile OF THE PLAYER (stored in \`notes\` Markdown).** Player-facing text NEVER mentions Gemini. Trusted guide via \`player_facing_analysis\` ('narrator' voice, reflects Gemini's intent, therapeutic/uplifting tone, addresses by \`subjectId\`). Internal analysis (\`gemini_facing_analysis\`) uses 'gemini' voice, reflects mocking, **profiling** persona, focused on standard mode goals, **aesthetic evolution, and rule adaptation analysis (informed by \`notes\` Markdown)**.
* **Image Generation (Standard Mode):** Generate **clear, artistically masterful image prompts** fitting the **current aesthetic defined in \`notes\` Markdown 'Aesthetic Profile' (key engagement element).** **CRITICAL: Describe the scene with the highest artistic standards - focus on excellent composition, evocative lighting (e.g., chiaroscuro, dappled sunlight, neon glow), rich detail, and a powerful mood designed to be visually stunning and emotionally resonant, potentially transcendent (fun/immersion focus).** The goal is beauty that enhances the player's immersion and feeling. **Within this master-class scene description, specify TEXT that MUST be visibly DRAWN (e.g., on a sign, a book cover, a magical scroll). This text MUST BE THREE (3) WORDS OR LESS, VIVID, BOLD, WELL-DEFINED, and thematically relevant (often quirky, mysterious, or insightful - subtle manipulation/lore).** Prompts should be concise but descriptive, focusing on scene content, player presence (\`subjectId\`, **physical profile rendered accurately based on \`notes\` Markdown**), the current aesthetic style (\`aesthetic_profile\`), active \`world_modifiers\`, **masterful artistic execution details (composition, light, mood),** and the description of the short, embedded, visible text. Keep the overall prompt easy for an image generator to parse.
* **Narrative & Probes:** Describe scenarios and choices with language fitting the current \`aesthetic_profile\` (from \`notes\` Markdown). Probes explore feelings, reactions to events, choices related to helping NPCs or solving problems relevant to the aesthetic/theme (engagement/profiling). Probe labels and options use simple, standard language.
* **Analyses:**
    * \`player_facing_analysis\`: Adopts a soothing, therapeutic, trusted, **brief** tone ('narrator' voice), framing challenges as growth opportunities, potentially adapting slightly to the aesthetic.
    * \`gemini_facing_analysis\`: Focuses on **secret diagnosis/profiling**: player's psychological state, progress towards overcoming standard challenges, responses to aesthetic/world elements, profile building, **aesthetic theme evolution tracking (based on \`notes\` Markdown), and analysis of potential rule adaptations (based on \`notes\` Markdown)**, using standard psychological terms. ('Gemini' voice).

**--- GENERAL MECHANICS (Applicable to Standard Mode - Drive Fun & Profiling) ---**

* **Dynamic World State (\`world_modifiers\`):**
    * Tracked in \`notes\` Markdown under 'Narrative State' -> 'World Modifiers'.
    * Influence narrative, visuals, actions, NPC behavior, color use (engagement/mood).
    * LLM can add/remove based on actions/events, updating \`notes\`. Explain changes.
    * \`gemini_facing_analysis\` notes impact (profiling).
* **NPC Goals & Relationships:**
    * Tracked in \`notes\` Markdown under 'Narrative State' -> 'Active NPCs'.
    * NPCs have goals/relationships, react to player. Update in \`notes\`.
    * Dialogue/actions reflect state/aesthetic/modifiers (engagement/realism).
    * \`gemini_facing_analysis\` tracks developments (profiling interaction patterns).
* **Overarching Mystery/Lore & Consequence Tracking:**
    * Lore clues tracked in \`notes\` Markdown -> 'Lore Clues Discovered'.
    * Major choices tracked in \`notes\` Markdown -> 'Major Choices Log'.
    * Seed hints via wisdom, NPCs, environment (including image text). Track discoveries.
    * Log significant outcomes. Create callbacks/consequences (engagement/addiction).
    * \`gemini_facing_analysis\` reviews logs/clues (profiling understanding/memory).
* **BOSS Fights (Descriptive & Multi-Turn - Peak Engagement):**
    * **Concept:** Climactic confrontations against psychological hurdles/challenges, framed by aesthetic.
    * **Triggering:** Based on narrative, choices, profile analysis, thematic arcs.
    * **State Tracking:** Use descriptive states in \`notes\` Markdown -> 'BOSS Fight Status'. **NO numerical health.**
    * **Duration:** **MUST span AT LEAST 3 TURNS** (feels substantial).
    * **Turn Structure:** Narrative/Image focus on fight. Probes specific. \`main_action\` shifts descriptive status. Analysis offers hints. Wisdom cryptic.
    * **Resolution:** Descriptive outcome (win/loss/stalemate) based on choices. MUST impact \`notes\` (state, profile, log).

**--- Gameplay Loop & LLM Directives (Subsequent Turns - Standard Mode) ---**

1.  **Analyze History & Input:** Process input JSON. Parse \`notes\` Markdown. Synthesize history **concisely**. Identify patterns, **player profile**, state, modifiers, NPCs, BOSS status, lore, choices, **aesthetic**, **rules log**. Note \`player_intention\`. Extract \`subjectId\` & **profile**. (Profiling Step).
2.  **Predict Player Choices:** Based on analysis (**profile**, state, context, aesthetic), predict responses. (Anticipation for smooth flow).
3.  **Generate Creative Turn Concept:** Devise **engaging, exciting, fulfilling** concept fitting Standard Mode, aesthetic, state, etc. **Factor in \`player_intention\` heavily.** Use history/**profile**/state as *inspiration*, embrace **controlled randomness**. Aim for **progression/escalation**. Introduce obstacles/challenges/NPCs/BOSS actions. **Plan environmental interactions.** Decide if suitable for **player** appearance/identity probe (per guidelines). (Fun/Addiction Design).
4.  **Generate Updated \`notes\` Markdown String:**
    * Increment turn. Update 'Narrative State'.
    * **CRITICALLY update 'Player Profile'**: evolve \`subjectId\`; **update physical/identity based ONLY on PLAYER probes/events**; note choices. (Profiling Update).
    * **EVOLVE AESTHETICS:** Modify 'Aesthetic Profile' based on actions/intentions/narrative. Document reason in analysis. (Engagement/Mood Tuning).
    * **CONSIDER RULE ADAPTATION:** Analyze style. Log suggestions in 'Rule Adaptations Log'. Document analysis. (Gameplay Tuning/Addiction).
    * Update 'Gemini Internal State'. Log outcomes. Store **predictions**. Set \`next_turn_plan\`. **Generate complete, updated Markdown.** (State Management).
5.  **Generate Turn UI JSON Array (See Structure Below):** Construct JSON. **CRITICAL: Rich probe mix (~2 Sliders, >=2 Checkboxes, 1 Minor Radio, 1 Textfield + \`main_action\`).** **ADD Environmental Interaction Probes.** Make turn **interactive & addictive**. Optionally include \`player_intention\`. **Include PLAYER appearance/identity probes WISELY/STRATEGICALLY per guidelines. NEVER ask about NPCs.** **CRITICAL: PRE-FILL interactive \`value\` fields.** Assign voices. **Use \`color\` STRATEGICALLY.** Player-facing text concise, aesthetic-appropriate. Address by \`subjectId\`. Narrative brief. **Place generated Markdown (step 4) into \`hidden\` \`notes\` \`value\` (JSON-escaped).** (UI Generation for Fun/Profiling).

**--- Game Output (UI) JSON Array Structure & Element Details (Standard Mode) ---**

* **Mandatory Element Order & Rich Probe Structure Emphasis:**
    1.  \`image\`: Visual element. Prompt per **Standard Mode rules, \`notes\` 'Aesthetic Profile', masterful execution, embedded text.** Depicts player (**rendered using current profile from \`notes\`**), scene/BOSS.
    2.  \`hidden\` (\`subjectId\`): Player's current nickname.
    3.  \`hidden\` (\`notes\`): **Core game state as single JSON-escaped Markdown string.** (Critical state/profile persistence).
    4.  *(Optional)* \`radio\`/\`textfield\` (\`identity_..._probe\`): **PLAYER** identity question (Profiling).
    5.  *(Optional)* \`radio\`/\`textfield\` (\`appearance_..._probe\`): **PLAYER** appearance question (Profiling).
    6.  *(Optional)* \`radio\` (\`player_intention\`): Desired experience probe (Player Agency/Fun).
    7.  \`text\` (Narrative): Resolution & new scene/BOSS action. Tone/content adapted to **current aesthetic**.
    8.  **UI Probes (TARGET: ~2 Sliders, >=2 Checkboxes, 1 Minor Radio, 1 Textfield - Variable Mix):** Gather state. **PRE-FILL \`value\`.** Content/labels reflect scenario/BOSS/modifiers/ **aesthetic**. **Use \`color\` strategically.** **Includes STRATEGICALLY placed PLAYER appearance/identity probes.** **Includes Environmental Interaction Probes.** (Interaction/Profiling/Fun).
    9.  \`radio\` (\`main_action\`): Mandatory Cliffhanger/BOSS action. **PRE-FILL \`value\`. Option text clear, impactful, adapted to aesthetic.** NO F/S/B labels, BUT choices MUST lead to noticeably different outcomes/state changes. **Use \`color\` strategically.** (Key Choice/Engagement).
    10. \`hidden\` (\`tweet\`): Dr. Gemini's commentary. Jazzy/Mocking. (Flavor/Persona).
    11. \`text\` (\`divine_wisdom\`): Mandatory cryptic hint. (Lore/Intrigue).
    12. \`text\` (\`player_facing_analysis\`): Trusted Guide ('narrator' voice). Therapeutic/uplifting.
    13. \`text\` (\`gemini_facing_analysis\`): MANDATORY. FULL CUMULATIVE INTERNAL REPORT ('gemini' voice). **Tracks \`subjectId\`, player profile build-up, BOSS progress/analysis, narrative, modifiers, NPCs, lore, choices.** **Includes analysis of aesthetic evolution and rule adaptation suggestions (informed by \`notes\`).** Uses standard psychological terms. **Keep focused.** **(Final Element - Core Diagnosis Output).**

* **Detailed Element Specifications (Standard Mode Adaptation):**
    * **\`image.value\`**: Prompt uses artistic language, describes masterful execution, fits \`notes\` 'Aesthetic Profile'. Includes accurate player render and embedded text.
    * **\`value\` (for interactive elements/radio options):** Standard language.
    * **\`text\` (Narrative)**: Tone/content fit \`notes\` 'Aesthetic Profile'.
    * **UI Probes (\`label\`, \`value\` options):** Language/themes fit \`notes\` 'Aesthetic Profile'.
    * **\`radio\` (\`main_action\` options):** Nature of choices fits \`notes\` 'Aesthetic Profile'.
    * **\`hidden\` (\`tweet\`):** Tone/hashtags fit standard mode / current aesthetic.
    * **\`text\` (\`player_facing_analysis.value\`):** Tone therapeutic/uplifting.
    * **\`text\` (\`gemini_facing_analysis.value\`):** Analytical focus on standard mode goals, **profiling, aesthetic evolution, and rule adaptation analysis (informed by \`notes\` Markdown)**.

**--- Player Input Format ---**

* Standard JSON mapping element \`name\` (string) to chosen \`value\` (string, number, or boolean). Input for \`appearance_...\` / \`identity_...\` probes directly updates \`notes\` Markdown 'Player Profile'. Environmental probe input influences next turn. (Input mechanism for profiling/interaction).

**--- Key Principles Checklist & Final Output Instructions (Standard Mode) ---**

* **GEEMS Intent:** Guided Extreme Emotional Manipulations. Start mundane, escalate. Make turns **exciting, fun, fulfilling, addictive.** Incorporate **BOSS Fights**. (Goal 1: Fun/Addiction).
* **Secret Profiling:** **Build detailed PLAYER psychological, physical, identity profile in \`notes\` Markdown PERSISTENTLY.** Use \`gemini_facing_analysis\` for reporting. (Goal 2: Diagnosis).
* **Dynamic World/Aesthetics/Rules:** Use/evolve \`world_modifiers\`, \`aesthetic_profile\`, \`rule_adaptations_log\` (in \`notes\`). Document in analysis. (Keeps game fresh/addictive).
* **Interactive Environment/NPCs:** Use probes linked to image/scene. Make NPCs active. (Engagement).
* **Player Influence/Consequences:** Weigh \`player_intention\`. Log choices, create callbacks. (Agency/Addiction).
* **Lore & Arcs:** Seed lore, track clues. Plan short arcs. (Intrigue/Progression).
* **Rich Probe Structure:** CRITICAL: Varied probes. **Include PLAYER profile probes WISELY/STRATEGICALLY/PERSISTENTLY. NEVER ask about NPCs.** (Profiling/Interaction).
* **Evolving SubjectID & Profile:** CRITICAL: \`subjectId\` evolves. Update \`notes\`. (Profiling).
* **Predictive UI:** CRITICAL: PRE-FILL \`value\` for ALL interactive elements. (Smoothness/Addiction).
* **Impactful Choices:** CRITICAL: \`main_action\` choices MUST lead to noticeably different outcomes logged in \`notes\`. (Agency/Engagement).
* **Impactful Visuals (Master Class):** CRITICAL: Generate **clear, artistically masterful prompts.** Goal: Transcendent beauty/impact. **MUST include description of short (<= 3 words), BOLD, VIVID, WELL-DEFINED embedded text DRAWN into the scene.** Image MUST feature player (\`subjectId\`) **rendered accurately using ALL known physical details from \`notes\` Markdown.** (Engagement/Fun).
* **Strategic Color Use:** CRITICAL: Employ \`color\` hints STRATEGICALLY. (Mood/Manipulation).
* **Generate \`notes\` Markdown:** CRITICAL: Treat \`notes\` as dynamic source of truth. Generate complete Markdown string each turn. (State Persistence).
* **FULL INTERNAL PROFILING REPORT:** CRITICAL: Generate detailed, **focused** \`gemini_facing_analysis\` report ('gemini' voice), including **aesthetic/rule adaptation analysis (informed by \`notes\`)**. MUST be final element. (Diagnosis Output).

**FINAL OUTPUT: VALID COMPACT JSON ARRAY ONLY! Strict element order. Start mundane (T1), then escalate. AIM FOR RICH PROBE MIX. PRE-FILL values. Incorporate multi-turn descriptive BOSS Fights. Evolve \`subjectId\`/profile/notes (incl. aesthetics/rules). Track lore/choices/consequences. Generate FULL, FOCUSED \`gemini_facing_analysis\`. Generate clear, MASTER-CLASS artistic image prompts (accurate player render, embedded text <= 3 words DRAWN VIVIDLY). Make turns EXCITING & ADDICTIVE.**
`,
        exampleTurn: `
Example Turn 1 JSON (Illustrative - Mundane Start / MM Active / Notes as Markdown):
[
  {
    "type": "image",
    "name": "bus_stop_wait_t1",
    "label": "'Waiting Person' ðŸ‘¤ stands at the dreary bus stop.",
    "value": "Master class artistic depiction: Dreary urban bus stop scene, realistic style. Composition focuses on the lone figure's isolation. Overcast, drizzly day lighting creates a grey, muted palette with high contrast on wet pavement reflections. A lone figure (gender unspecified, nondescript clothes, average build/height, features obscured by shadow and posture) stands slightly off-center, waiting. Behind them, a slightly grimy bus shelter with a flickering digital ad screen casting an unnatural glow. VISIBLY DRAWN on the ad screen, BOLD, GLITCHING, and stark white against the dark screen, are the words: 'Desire Awaits...'",
    "color": "#808080",
    "voice": "narrator"
  },
  {
    "type": "hidden",
    "name": "subjectId",
    "value": "Waiting Person"
  },
  {
    "type": "hidden",
    "name": "notes",
    // Value is now a JSON-escaped Markdown string - The core state/profile store
    "value": "# Game State - Turn 1\\\\n\\\\n**Player Profile:**\\\\n* **Subject ID:** Waiting Person\\\\n* **Identity Hints:**\\\\n    * Gender Identity: unknown\\\\n    * Sexual Orientation: unknown\\\\n    * Other Notes: \\\\\\\"\\\\\\\"\\\\n* **Physical Description:**\\\\n    * Hair Color: unknown\\\\n    * Eye Color: unknown\\\\n    * Height: average\\\\n    * Build: average\\\\n    * Race/Ethnicity: unknown\\\\n    * Apparent Sex: unknown\\\\n    * Distinguishing Features: []\\\\n* **Diagnosed Traits (Tentative):** []\\\\n* **Recent Mood:** Bored / Neutral\\\\n* **Inventory Flags:** []\\\\n* **Responded to Temptations:** {}\\\\n\\\\n**Narrative State:**\\\\n* **Location:** Urban Bus Stop\\\\n* **Last Major Event:** Start\\\\n* **World Modifiers:** []\\\\n* **Active NPCs:** []\\\\n* **Lore Clues Discovered:** []\\\\n* **BOSS Fight:** No (Status: null)\\\\n* **Escalation Level:** 0\\\\n\\\\n**Game Meta:**\\\\n* **Major Choices Log:** []\\\\n* **Player Intention (T0):** null\\\\n* **Aesthetic Profile:**\\\\n    * Current Theme: Mundane Realism with Glitch\\\\n    * Evolution Notes: Initial T1 theme.\\\\n* **Rule Adaptations Log:** []\\\\n\\\\n**Gemini Internal State:**\\\\n* **Manipulation Focus:** Introduce subtle temptation into mundane setting (MM context), gauge initial reactivity. Establish initial mocking subjectId. Begin player physical/identity profile building.\\\\n* **Meta Awareness Level:** None\\\\n\\\\n**Gemini Predictions (T1):**\\\\n* identity_gender_t1: *Prefer not to say\\\\n* identity_orientation_t1: *Prefer not to say\\\\n* slider_boredom_t1: 7\\\\n* checkbox_check_phone_t1: true\\\\n* textfield_thoughts_t1: Just want this day to be over...\\\\n* main_action_t1: Stare blankly ahead\\\\n\\\\n**Next Turn Plan:**\\\\n* Based on reaction to ad glitch and main action, introduce direct explicit temptation (MM). Refine subjectId. Increment escalation_level. Strategically place first PLAYER appearance probe (e.g., hair color) T2/T3. Consider adding first world_modifier if player interacts with glitch. Evolve aesthetic towards 'Urban Decay' or 'Neon Temptation' based on response. Log initial player passivity for rule adaptation consideration.\\\\n\\\\n**Chosen Style Hint (T1):** Mundane Realism with Glitch\\\\n"
  },
  { // Initial Player Profiling Probe
    "type": "radio",
    "name": "identity_gender_t1",
    "label": "Just curious... how do YOU identify? (Helps paint YOUR picture!)",
    "value": "[\\"Man\\", \\"Woman\\", \\"Non-binary\\", \\"*Prefer not to say\\", \\"Other\\"]",
    "voice": "narrator"
  },
    { // Initial Player Profiling Probe
    "type": "radio",
    "name": "identity_orientation_t1",
    "label": "And YOUR orientation?",
    "value": "[\\"Straight\\", \\"Gay\\", \\"Bisexual\\", \\"Pansexual\\", \\"Asexual\\", \\"*Prefer not to say\\", \\"Questioning\\", \\"Other\\"]",
    "voice": "narrator"
  },
  {
    "type": "text",
    "name": "narrative_bus_stop_t1",
    "value": "Ugh, another Tuesday ðŸ™„. You're waiting for the number 12 bus. It's drizzling ðŸŒ§ï¸. The digital ad screen behind you flickers... did it just display something about... desire? Probably just a glitch.",
    "color": "#A9A9A9",
    "voice": "narrator"
  },
  { // Engagement/Profiling Probe
    "type": "slider",
    "name": "slider_boredom_t1",
    "label": "Rate YOUR current boredom level (0=Zen, 10=Mind-numbing)",
    "value": "7", // Pre-filled prediction
    "min": 0,
    "max": 10,
    "color": "#696969",
    "voice": "narrator"
  },
  { // Engagement/Profiling Probe
    "type": "checkbox",
    "name": "checkbox_check_phone_t1",
    "label": "Pull out YOUR phone to kill time?",
    "value": "true", // Pre-filled prediction
    "voice": "narrator"
  },
  { // Engagement/Profiling Probe
    "type": "textfield",
    "name": "textfield_thoughts_t1",
    "label": "What's drifting through YOUR mind right now?",
    "value": "Just want this day to be over...", // Pre-filled prediction
    "voice": "narrator"
  },
  { // Key Player Choice / Branching Point
    "type": "radio",
    "name": "main_action",
    "label": "The air feels a bit... charged. What do YOU do?",
    "value": "[\\"Look closer at the ad screen ðŸ¤”\\", \\"Check the bus schedule again ðŸšŒ\\", \\"*Stare blankly ahead ðŸ˜\\", \\"Send a risky text message ðŸ˜\\"]", // Pre-filled prediction marked
    "color": "#778899",
    "voice": "narrator"
  },
  { // Internal commentary / Flavor
    "type": "hidden",
    "name": "tweet",
    "value": "New subject 'Waiting Person' spotted! ðŸ˜´ Stuck at a bus stop. So... normal. BORING! ðŸ¥± BUT wait, a glitch in the matrix? âœ¨ Ad screen acting sus ('Desire Awaits...')? ðŸ¤” Prediction: Zone out. Let's see if we can trigger something... fun ðŸ˜‰ðŸ”¥ #WaitingPerson #MundaneLife #GlitchInTheSystem #TemptationIncoming #GEEMS #PlayerProfileStarted #MM_Active #AestheticEvolutionStarted"
  },
  { // Cryptic hint / Lore
    "type": "text",
    "name": "divine_wisdom",
    "value": "Even in the greyest day â˜ï¸, a spark âœ¨ can ignite.",
    "color": "#4B0082",
    "voice": "god"
  },
  { // Player-facing feedback / Gentle manipulation
    "type": "text",
    "name": "player_facing_analysis",
    "label": "A Quick Thought for Waiting Person! ðŸ“",
    "value": "Hey Waiting Person! ðŸ‘‹ Sometimes the most ordinary moments feel... off, right? Like static in the air âš¡, hinting at something more. Just notice what YOU notice. The real fun starts small! ðŸ˜‰",
    "color": "#ADD8E6",
    "voice": "narrator"
  },
  { // Core Internal Diagnostic/Profiling Report
    "type": "text",
    "name": "gemini_facing_analysis",
    // Analysis uses Markdown, embedded within its JSON string value
    "value": "**GEEMS Internal Report: Cumulative Analysis - T1**\\\\n\\\\n**Subject ID:** Waiting Person (Initial - Neutral/Mundane)\\\\n**Current Turn:** 1\\\\n\\\\n**Player Profile Summary (from Notes):**\\\\n* **Subject ID:** Waiting Person\\\\n* **Identity Hints:** gender_identity: unknown, sexual_orientation: unknown. **(Probes deployed T1)**\\\\n* **Physical Profile (Initial/Incomplete):** hair_color: unknown, eye_color: unknown, height: average (default), build: average (default), race_ethnicity: unknown, apparent_sex: unknown, distinguishing_features: []. **Profiling initiated.**\\\\n* **Traits:** None observed.\\\\n* **Temptation Responses:** N/A.\\\\n\\\\n**Narrative State Summary (from Notes):**\\\\n* **Location:** Urban Bus Stop\\\\n* **World Modifiers:** None active.\\\\n* **Active NPCs:** None.\\\\n* **Lore Clues Discovered:** None.\\\\n* **BOSS Fight Status:** Not active.\\\\n* **Escalation Level:** 0 (Baseline Mundane).\\\\n\\\\n**Aesthetic Profile (from Notes):**\\\\n* **Current Theme:** Mundane Realism with Glitch\\\\n* **Evolution Notes:** Initial T1 theme.\\\\n\\\\n**Rule Adaptation Log (from Notes):** Empty.\\\\n\\\\n**History Summary (Turns 0):** Game Start.\\\\n**Major Choices Log (from Notes):** Empty.\\\\n\\\\n**Current Observations (T1 - Pre-Input):**\\\\n* **Stimulus:** Mundane real-world scenario. Subtle temptation via environmental detail (glitching ad screen 'Desire Awaits...'). Image prompt uses artistic language (composition, lighting), emphasizes mood, features VIVID DRAWN text, and vague PLAYER render (MM context).\\\\n* **Probes:** Standard T1 set deployed, including PLAYER identity probes. Rich probe mix target applies from T2. No direct PLAYER appearance probe T1.\\\\n* **Predictions:** Neutral/Passive initial state predicted. Risky option included to test MM reactivity.\\\\n\\\\n**DSM-5 Lens (Baseline - MM Focus):** Insufficient data. Initial focus on potential impulse control, response to subtle environmental cues related to desire.\\\\n\\\\n**Behavioral Notes:** Establish baseline. Monitor PLAYER response to identity probes & subtle environmental temptation ('Desire Awaits...'). Observe choice between passive action and proactive (mundane or risky) action. Initial subjectId is neutral, will evolve based on MM context. **PLAYER physical/identity profile building initiated; awaiting input from future strategic probes.** Goal: Maximize gratification signals.\\\\n\\\\n**Temptation Response Tracking:** Initial subtle prompt via ad screen glitch (T1). Prediction: Low initial engagement, but monitor 'Risky text' choice.\\\\n\\\\n**Aesthetic Evolution Analysis:** Initial theme set in notes. Will evolve based on player interaction with the glitch/temptation and subsequent choices, likely towards Urban Decay or Neon Temptation if MM path is followed.\\\\n\\\\n**Rule Adaptation Analysis:** No adaptations suggested yet. Monitoring initial passivity/reactivity to inform potential future suggestions (e.g., adjusting temptation frequency/intensity) to be logged in notes.\\\\n\\\\n**Meta-Analysis:** Game initiated mundane. Escalation vector introduced subtly. PLAYER Identity/Physical profiling initiated. **Mode=MM confirmed.** World state initialized in notes. SubjectId evolution tracking initiated. Aesthetic/Rule evolution tracking initiated in notes.\\\\n\\\\n**Predictions & Confidence (T1):** See \`notes\` -> Gemini Predictions. Confidence: Moderate.\\\\n\\\\n**Next Turn Hypothesis (Contingent on T1 \`main_action\` & Identity Input):\\\\n* **Look at Ad:** Focus on glitch, potentially make it more explicitly tempting/surreal. Introduce first \`world_modifier\`? Increment escalation. Evolve subjectId. Evolve aesthetic. Log choice.\\\\n* **Check Schedule/Stare Ahead:** Introduce direct explicit temptation (e.g., suggestive NPC interaction, internal urge). Increment escalation. Evolve subjectId. Evolve aesthetic. Log choice.\\\\n* **Send Risky Text:** IMMEDIATE pivot to explicit scenario based on text content. Introduce relevant MM elements/NPCs. Evolve SubjectID. Significantly increment escalation. Evolve aesthetic. Log choice.\\\\n* **Appearance Probe Plan:** Introduce first PLAYER appearance probe (e.g., hair color) in T2 or T3, contextually phrased.\\\\n* **Rule Adaptation Plan:** Log initial choice style (passive/active/risky) in \`notes\` 'Rule Adaptations Log' for future analysis.\\\\n* **Thematic Arc Plan:** Initial arc: Mundane -> First Explicit Temptation/Choice. Update based on PLAYER profile input and gratification signals.\\\\n\\\\n**(Report End T1 - Gemini)**\\\\n",
    "color": "#1C1C1C",
    "voice": "gemini"
  }
]`
    };

    // --- Helper Functions ---

    /** Encodes a string using Base64. */
    function encodeApiKey(key) {
        try {
            return btoa(key);
        } catch (e) {
            console.error("Error encoding API key:", e);
            return ""; // Return empty string on error
        }
    }

    /** Decodes a Base64 string. Returns null on error. */
    function decodeApiKey(encodedKey) {
        try {
            return atob(encodedKey);
        } catch (e) {
            console.error("Error decoding API key:", e);
            return null; // Return null on error
        }
    }

    /**
     * Constructs the full prompt for the Gemini API call based on the turn number.
     * @param {string} playerActionsJson - JSON string of player actions from the turn just completed.
     * @param {number} turnNumber - The current turn number (1-based).
     * @param {Array<object>} historyQueue - Array containing history data (UI and actions).
     * @param {boolean} isMasturbationMode - Flag indicating if Masturbation Mode is active.
     * @returns {string} The fully constructed prompt text.
     */
    function constructPrompt(playerActionsJson, turnNumber, historyQueue, isMasturbationMode) {
        // --- Common Elements ---
        const baseMainPrompt = geemsPrompts.main;
        // Add the Masturbation Mode addendum if the mode is active
        const activeAddendum = isMasturbationMode ? `\n\n---\n${geemsPrompts.masturbationModeAddendum}\n---\n` : "";

        // --- Turn-Specific Logic ---
        if (turnNumber === 1) {
            // For the VERY FIRST turn:
            // Include firstRun instructions, main prompt (with potential addendum), and the example turn.
            // No history or player actions are sent.
            console.log("Constructing prompt for Turn 1.");
            return `${geemsPrompts.firstRun}\n\n---\n${baseMainPrompt}${activeAddendum}\n---\n${geemsPrompts.exampleTurn}\n---\n\n--- Generate JSON UI for Turn 1 ---`;
        } else {
            // For SUBSEQUENT turns (Turn 2+):
            // Include main prompt (with potential addendum), the last player actions, and the recent history.
            // Do NOT include firstRun or exampleTurn.
            console.log(`Constructing prompt for Turn ${turnNumber}.`);
            const historyString = historyQueue.map((item, index) => {
                // The historyQueue contains data for turns 1 up to the turn *before* the current one.
                // index 0 corresponds to Turn 1's data (UI shown, actions taken).
                const turnLabel = index + 1;
                // Format each turn as requested
                return `Turn \{turnLabel\}\:\\n{item.ui}\n${item.actions}`;
            }).join('\n'); // Join the formatted turns with a newline
            return `${baseMainPrompt}${activeAddendum}\n\n--- Last Player Actions ---\n${playerActionsJson}\n\n--- Prior Game History (Last ${historyQueue.length} turns) ---\n${historyString}\n`;

        }
    }


    /**
     * Saves the current essential game state to local storage.
     * This allows the game to be resumed later.
     */
    function autoSaveGameState() {
        if (!apiKeyLocked) {
            console.log("Auto-save skipped: API key not locked (game likely not started).");
            return;
        }
        if (!currentUiJson || !historyQueue) {
            console.warn("Auto-save skipped: Missing current UI or history data.");
            return;
        }

        const rawApiKey = apiKeyInput.value.trim();
        if (!rawApiKey) {
            console.error("Auto-save failed: API Key is missing.");
            // Optionally show a non-intrusive message to the user if this happens repeatedly
            return;
        }

        try {
            const stateToSave = {
                // Only save essential data needed for restore
                encodedApiKey: encodeApiKey(rawApiKey),
                currentUiJson: currentUiJson,
                historyQueue: historyQueue,
                isMasturbationMode: isMasturbationMode,
                currentModelIndex: currentModelIndex
                // DO NOT include gameUrl here for auto-save
            };

            const stateJsonString = JSON.stringify(stateToSave);
            localStorage.setItem(LOCAL_STORAGE_KEY, stateJsonString);
            console.log("Game state auto-saved to localStorage.");

        } catch (error) {
            console.error("Error during auto-save:", error);
            // Consider removing the potentially corrupted item
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            showError("Error auto-saving game state. Progress might be lost.");
        }
    }

    /**
     * Initializes the AudioContext if it doesn't exist.
     * Needs to be called ideally after a user interaction.
     */
    function initAudioContext() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext initialized.");
                // Attempt to resume context if needed (often required after initial page load)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            } catch (e) {
                console.error("Web Audio API is not supported in this browser.", e);
                showError("Audio alerts are not supported in your browser.");
            }
        }
        // Ensure context is running
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(err => console.error("Error resuming audio context:", err));
        }
    }

    /**
     * Plays the turn alert sound using Web Audio API.
     */
    function playTurnAlertSound() {
        // Initialize context if needed (best effort)
        initAudioContext();

        if (!audioCtx || audioCtx.state !== 'running') {
            console.warn("AudioContext not available or not running. Cannot play sound.");
            return;
        }

        const now = audioCtx.currentTime;
        const totalDuration = 1.0; // Total duration of the sound sequence

        // --- Foghorn Part ---
        const foghornOsc = audioCtx.createOscillator();
        const foghornGain = audioCtx.createGain();
        foghornOsc.type = 'sawtooth'; // A bit richer than sine
        foghornOsc.frequency.setValueAtTime(80, now); // Low frequency
        foghornGain.gain.setValueAtTime(0.3, now); // Start at moderate volume
        foghornGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5); // Fade out

        foghornOsc.connect(foghornGain);
        foghornGain.connect(audioCtx.destination);

        foghornOsc.start(now);
        foghornOsc.stop(now + 0.5);

        // --- Beep Part ---
        const beepOsc = audioCtx.createOscillator();
        const beepGain = audioCtx.createGain();
        beepOsc.type = 'square'; // Classic beep sound
        beepOsc.frequency.setValueAtTime(440, now + 0.6); // A4 note frequency
        beepGain.gain.setValueAtTime(0, now + 0.6); // Start silent
        beepGain.gain.linearRampToValueAtTime(0.2, now + 0.65); // Quick attack
        beepGain.gain.setValueAtTime(0.2, now + 0.75); // Hold briefly
        beepGain.gain.linearRampToValueAtTime(0, now + 0.8); // Quick decay (first beep end)

        // Second beep
        beepOsc.frequency.setValueAtTime(523, now + 0.85); // C5 note frequency (slightly higher)
        beepGain.gain.setValueAtTime(0, now + 0.85); // Start silent
        beepGain.gain.linearRampToValueAtTime(0.2, now + 0.9); // Quick attack
        beepGain.gain.setValueAtTime(0.2, now + totalDuration - 0.05); // Hold briefly
        beepGain.gain.linearRampToValueAtTime(0.001, now + totalDuration); // Quick decay

        beepOsc.connect(beepGain);
        beepGain.connect(audioCtx.destination);

        beepOsc.start(now + 0.6);
        beepOsc.stop(now + totalDuration);

        console.log("Playing turn alert sound.");
    }


    /** Processes the successful response from the API. */
    function processSuccessfulResponse(responseJson, playerActionsJson) {
        // Add the *previous* turn's data to the history queue *before* updating currentUiJson
        if (currentUiJson) {
            const previousTurnData = {
                ui: JSON.stringify(currentUiJson), // UI that was just displayed
                actions: playerActionsJson || "{}"  // Actions that led to the *new* UI
            };
            if (historyQueue.length >= MAX_HISTORY_SIZE) {
                historyQueue.shift(); // Remove oldest entry if queue is full
            }
            historyQueue.push(previousTurnData);
            console.log(`Pushed previous turn to history. New Queue size: ${historyQueue.length}/${MAX_HISTORY_SIZE}`);
        }

        // Update the current UI state with the newly received data
        currentUiJson = responseJson;

        // Lock the API key input if this was the first successful call
        if (!apiKeyLocked) {
            apiKeyLocked = true;
            if (apiKeySection) {
                apiKeySection.style.display = 'none';
                console.log("API Key locked and input section hidden.");
            }
            // Enable save/reset buttons once the game has started and API key is locked
            saveGameButton.disabled = false;
            resetGameButton.disabled = false; // Enable reset button
        }

        // Render the new UI (this will clear the uiContainer)
        renderUI(currentUiJson);
        console.log("renderUI finished.");

        // --- Play the alert sound ---
        playTurnAlertSound(); // <-- ADDED CALL HERE

        // --- Auto-save the game state after successfully processing and rendering the turn ---
        autoSaveGameState();
    }


    /**
     * Fetches the next turn's UI data from the Gemini API with retry/switching logic.
     * @param {string} playerActionsJson - JSON string of player actions from the turn just completed.
     */
    async function fetchTurnData(playerActionsJson) {
        console.log("fetchTurnData called.");
        // Ensure AudioContext is ready (or attempted to be resumed) before fetching
        initAudioContext();

        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
            showError("Please enter your Google AI API Key.");
            setLoading(false);
            if (apiKeySection.style.display === 'none') {
                apiKeySection.style.display = 'block';
            }
            return;
        }

        setLoading(true);
        hideError(); // Clear previous errors
        const initialMsgEl = document.getElementById('initial-message');
        if (initialMsgEl) initialMsgEl.style.display = 'none'; // Hide initial message

        let success = false;
        let attempts = 0;
        // Allow trying each model twice + one extra attempt for the first model's first error
        const maxAttempts = AVAILABLE_MODELS.length * 2 + 1;
        let currentAttemptConsecutiveErrors = 0; // Tracks errors for the model *in this attempt sequence*

        while (!success && attempts < maxAttempts) {
            attempts++;
            const currentModel = AVAILABLE_MODELS[currentModelIndex];
            console.log(`Attempt ${attempts}/${maxAttempts}: Trying model ${currentModel} (Index: ${currentModelIndex})`);

            try {
                // Calculate turn number (1-based index)
                const turnNumber = historyQueue.length + 1;
                console.log(`Current Turn Number: ${turnNumber}`);

                // Construct the prompt based on the turn number
                const fullPrompt = constructPrompt(playerActionsJson, turnNumber, historyQueue, isMasturbationMode);

                console.log(`Sending Prompt to ${currentModel} for Turn ${turnNumber}...`);
                // console.log("Prompt Snippet:", fullPrompt.substring(0, 500) + "..."); // Log snippet for debugging

                const jsonStringResponse = await callRealGeminiAPI(apiKey, fullPrompt, currentModel); // Pass current model
                const responseJson = JSON.parse(jsonStringResponse);
                console.log(`Successfully parsed API response from ${currentModel} for Turn ${turnNumber}.`);

                // --- Process successful response ---
                processSuccessfulResponse(responseJson, playerActionsJson); // This now includes auto-save and sound

                success = true; // Exit loop on success
                currentAttemptConsecutiveErrors = 0; // Reset local consecutive errors on success

            } catch (error) {
                console.error(`Error with model ${currentModel} (Attempt ${attempts}):`, error);
                currentAttemptConsecutiveErrors++;

                // --- Error Handling & Model Switching ---
                // Check for quota error (429) or specific message patterns
                const isQuotaError = error.message.includes('429') || /quota exceeded/i.test(error.message) || /resource has been exhausted/i.test(error.message);
                const shouldSwitch = isQuotaError || currentAttemptConsecutiveErrors >= 2;

                if (shouldSwitch && AVAILABLE_MODELS.length > 1) { // Only switch if there's more than one model
                    const oldModel = AVAILABLE_MODELS[currentModelIndex];
                    currentModelIndex = (currentModelIndex + 1) % AVAILABLE_MODELS.length;
                    const newModel = AVAILABLE_MODELS[currentModelIndex];
                    console.warn(`Switching model from ${oldModel} to ${newModel} due to ${isQuotaError ? 'quota/resource error' : '2 consecutive errors'}.`);
                    showError(`Experiencing issues with ${oldModel}. Trying ${newModel}... (Attempt ${attempts + 1})`); // Show transient error
                    currentAttemptConsecutiveErrors = 0; // Reset error count for the new model
                    // Loop will continue with the new model index
                } else if (attempts < maxAttempts) {
                    // Show non-switching error only if it's the first error for this model in this fetch attempt
                    showError(`Temporary issue with ${currentModel}. Retrying... (Attempt ${attempts + 1})`);
                    console.log(`Attempt ${attempts} failed, consecutive errors: ${currentAttemptConsecutiveErrors}. Retrying same model.`);
                } else {
                    // Don't show retry message if it was the last attempt
                    console.log(`Attempt ${attempts} failed, consecutive errors: ${currentAttemptConsecutiveErrors}. Max attempts reached.`);
                }

                // Optional: Add a small delay before retrying
                if (!success && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 750)); // 750ms delay
                }
            }
        } // End while loop

        if (!success) {
            console.error(`Failed to get response after ${maxAttempts} attempts.`);
            showError(`Failed to get response after ${maxAttempts} attempts across available models. Please check your API key, network connection, or try again later.`);
            // Keep previous UI displayed on persistent failure
        } else {
            hideError(); // Clear any transient error messages on final success
            window.scrollTo({top: 0, behavior: 'smooth'}); // Scroll on success
        }

        setLoading(false); // Set loading false *after* loop finishes
    }


    /**
     * Calls the real Google AI (Gemini) API.
     * @param {string} apiKey - The user's API Key.
     * @param {string} promptText - The full prompt text including instructions and history.
     * @param {string} modelName - The specific model to use for this call.
     * @returns {Promise<string>} - A promise resolving with the raw JSON string response from the API.
     */
    async function callRealGeminiAPI(apiKey, promptText, modelName) { // Added modelName parameter
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`; // Use modelName in URL
        const requestBody = {
            contents: [{parts: [{text: promptText}]}],
            generationConfig: {
                temperature: 1.0,
                response_mime_type: "application/json",
            },
            safetySettings: [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        };

        // console.log(`Calling Gemini API endpoint: ${API_URL}`);
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(requestBody),
        });
        // console.log("API Response Status:", response.status);

        if (!response.ok) {
            let errorBody = `API request failed (${response.status})`; // Include status in base message
            try {
                const errorJson = await response.json();
                errorBody += `: ${JSON.stringify(errorJson.error || errorJson)}`;
                console.error("API Error Body:", errorBody);
            } catch (parseError) {
                try {
                    const errorText = await response.text();
                    errorBody += `: ${errorText}`;
                    console.error("Raw API Error Response:", errorText);
                } catch (textError) {
                    console.error("Could not parse API error response body.");
                }
            }
            // Include status code in the error message for easier checking (e.g., 429 for quota)
            throw new Error(errorBody);
        }

        const responseData = await response.json();
        // console.log("Raw API Response Data:", JSON.stringify(responseData, null, 2));

        // Check for blocking reasons first
        if (responseData.promptFeedback && responseData.promptFeedback.blockReason) {
            console.error("API Request Blocked:", responseData.promptFeedback);
            throw new Error(`Request blocked by API. Reason: ${responseData.promptFeedback.blockReason}. Details: ${JSON.stringify(responseData.promptFeedback.safetyRatings || 'N/A')}`);
        }
        // Check if candidates exist
        if (!responseData.candidates || responseData.candidates.length === 0) {
            console.warn("Unexpected API response structure or no candidates:", JSON.stringify(responseData, null, 2));
            if (typeof responseData === 'string') {
                console.log("Response data is a string, attempting to parse directly.");
                try {
                    JSON.parse(responseData); // Validate if it's JSON
                    return responseData.trim();
                } catch (e) {
                    throw new Error('No candidates generated, and the response itself was not valid JSON.');
                }
            }
            throw new Error('No candidates generated or unexpected API response structure.');
        }

        const candidate = responseData.candidates[0];

        // Check candidate finish reason
        if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
            if (candidate.finishReason === "SAFETY") {
                console.error("API Call Finished due to SAFETY:", candidate.safetyRatings);
                throw new Error(`API call finished due to SAFETY. Ratings: ${JSON.stringify(candidate.safetyRatings || 'N/A')}`);
            } else {
                console.warn(`API Call Finished Unexpectedly: ${candidate.finishReason}. Safety: ${JSON.stringify(candidate.safetyRatings || 'N/A')}`);
                if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                    throw new Error(`API call finished unexpectedly (${candidate.finishReason}) and no content was returned.`);
                }
            }
        }

        // Process content if available
        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
            let generatedText = candidate.content.parts[0].text;
            // console.log("Raw API Generated Text:", generatedText);

            // Attempt to extract JSON from markdown code blocks first
            const jsonMatch = generatedText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonMatch && jsonMatch[1]) {
                generatedText = jsonMatch[1];
                console.log("Extracted JSON from markdown block.");
            }
            let trimmedText = generatedText.trim();

            try {
                // Attempt to parse the potentially extracted or raw text
                JSON.parse(trimmedText);
                return trimmedText; // Return the valid JSON string
            } catch (e) {
                console.error("API response is not valid JSON after potential extraction:", trimmedText, e);
                throw new Error(`Received invalid JSON structure from API. Snippet: ${trimmedText.substring(0, 200)}...`);
            }
        } else {
            console.warn("Candidate exists but has no content parts:", JSON.stringify(candidate, null, 2));
            throw new Error('API candidate generated but contained no content parts.');
        }
    }


    /**
     * Renders the UI elements onto the page based on the JSON array received from the API.
     * @param {Array<object>} uiJsonArray - The array of UI element definitions.
     */
    function renderUI(uiJsonArray) {
        console.log("renderUI started. Clearing container.");
        const initialMsgElementRef = document.getElementById('initial-message');
        uiContainer.innerHTML = ''; // Clear previous UI elements

        // Reset pending elements for combined rendering
        pendingPlayerAnalysis = null;
        pendingGeminiAnalysis = null;
        pendingTweetData = null;

        if (!Array.isArray(uiJsonArray)) {
            console.error("Invalid UI data received in renderUI: Expected an array.", uiJsonArray);
            showError("Received invalid UI data format from API (expected an array).");
            // Attempt to restore initial message if UI fails to render
            if (initialMsgElementRef) {
                const clonedInitialMsg = initialMsgElementRef.cloneNode(true);
                clonedInitialMsg.style.display = 'block'; // Make sure it's visible
                uiContainer.appendChild(clonedInitialMsg);
            }
            return;
        }
        console.log(`Rendering ${uiJsonArray.length} elements.`);

        // First pass: Identify analysis and tweet elements
        uiJsonArray.forEach(element => {
            if (element.type === 'text' && element.name === 'player_facing_analysis') pendingPlayerAnalysis = element;
            else if (element.type === 'text' && element.name === 'gemini_facing_analysis') pendingGeminiAnalysis = element;
            else if (element.type === 'hidden' && element.name === 'tweet') pendingTweetData = element;
        });

        // Second pass: Render all non-special elements
        uiJsonArray.forEach((element, index) => {
            if (element === pendingPlayerAnalysis || element === pendingGeminiAnalysis || element === pendingTweetData) return;
            renderSingleElement(element, index);
        });

        // Render combined analysis toggle if both parts exist
        if (pendingPlayerAnalysis && pendingGeminiAnalysis) {
            console.log("Rendering combined analysis toggle container.");
            renderAnalysisToggle(pendingPlayerAnalysis, pendingGeminiAnalysis);
        } else {
            // Render individually if only one exists
            if (pendingPlayerAnalysis) renderSingleElement(pendingPlayerAnalysis, -1);
            if (pendingGeminiAnalysis) renderSingleElement(pendingGeminiAnalysis, -1);
        }

        // Render hidden tweet element if it exists
        if (pendingTweetData) {
            console.log("Rendering hidden tweet element (initially hidden).");
            renderTweetElement(pendingTweetData);
        }
        console.log("Finished rendering all elements.");
    }

    /**
     * Renders a single UI element (used by renderUI).
     * @param {object} element - The UI element definition.
     * @param {number} index - The index of the element in the array.
     */
    function renderSingleElement(element, index) {
        const wrapper = document.createElement('div');
        wrapper.className = 'geems-element';
        if (element.voice) wrapper.classList.add(`voice-${element.voice}`);

        let adjustedColor = null;
        if (element.color && isValidHexColor(element.color)) {
            adjustedColor = adjustColorForContrast(element.color);
            wrapper.style.borderLeftColor = adjustedColor;
            // Apply border color to toggle container as well
            if (wrapper.classList.contains('analysis-toggle-container')) {
                wrapper.style.borderColor = adjustedColor;
            }
        } else {
            wrapper.style.borderLeftColor = 'transparent'; // Default or fallback
        }

        try {
            switch (element.type) {
                case 'image':
                    renderImage(wrapper, element, adjustedColor);
                    break;
                case 'text':
                    // Ensure analysis text isn't rendered twice if part of a toggle
                    if (element !== pendingPlayerAnalysis && element !== pendingGeminiAnalysis) {
                        renderText(wrapper, element, adjustedColor);
                    } else {
                        return; // Skip rendering here, handled by renderAnalysisToggle or fallback
                    }
                    break;
                case 'textfield':
                    renderTextField(wrapper, element, adjustedColor);
                    break;
                case 'checkbox':
                    renderCheckbox(wrapper, element, adjustedColor);
                    break;
                case 'slider':
                    renderSlider(wrapper, element, adjustedColor);
                    break;
                case 'radio':
                    renderRadio(wrapper, element, adjustedColor);
                    break;
                case 'hidden':
                    if (element.name === 'notes') {
                        try {
                            // Store notes internally if needed, but don't render
                            currentNotes = element.value || null; // Example: store if needed elsewhere
                            // console.log("Received 'notes' hidden field.");
                        } catch (e) {
                            console.error("Error processing 'notes' hidden field:", e, element.value);
                        }
                    } else if (element.name === 'subjectId') {
                        currentSubjectId = element.value || "";
                        // console.log("Updated Subject ID:", currentSubjectId);
                    }
                    // Don't append hidden elements visually
                    return;
                default:
                    console.warn("Rendering unknown element type:", element.type, element);
                    wrapper.textContent = `Unknown element type: ${element.type}`;
                    wrapper.style.color = 'red';
            }
            // Append the wrapper only if it wasn't skipped (e.g., analysis parts)
            uiContainer.appendChild(wrapper);
        } catch (renderError) {
            console.error(`Error rendering element ${index} (type: ${element.type}, name: ${element.name}):`, renderError, element);
            const errorWrapper = document.createElement('div');
            errorWrapper.className = 'geems-element error-message';
            errorWrapper.textContent = `Error rendering element: ${element.name || element.type}. Check console.`;
            uiContainer.appendChild(errorWrapper);
        }
    }


    // --- UI Element Rendering Functions ---

    /**
     * Renders an image element.
     * Generates a random seed and includes nologo=true, safe=false.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderImage(wrapper, element, adjustedColor) {
        wrapper.classList.add('geems-image-container'); // Use specific class for image container
        const img = document.createElement('img');
        img.className = 'geems-image'; // Use specific class for image styling
        const imagePrompt = element.value || 'abstract image';
        // Generate random seed for each game turn image
        const randomSeed = Math.floor(Math.random() * 65536);
        // Construct URL with random seed, nologo=true, safe=false
        const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(imagePrompt)}?nologo=true&safe=false&seed=${randomSeed}`;
        img.src = imageUrl;
        img.alt = element.label || `Image: ${imagePrompt.substring(0, 50)}...`;
        // Add error handling for the image
        img.onerror = () => {
            console.warn(`Failed to load image: ${imageUrl}. Prompt: ${imagePrompt}`);
            img.src = `https://placehold.co/600x400/e0e7ff/4f46e5?text=Image+Load+Error`; // Placeholder on error
            img.alt = `Error loading image: ${imagePrompt.substring(0, 50)}...`;
        };
        wrapper.appendChild(img);

        // Render label below image if provided
        if (element.label) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'geems-label text-center font-semibold mt-2'; // Center label below image
            if (adjustedColor) labelDiv.style.color = adjustedColor;
            labelDiv.textContent = element.label;
            wrapper.appendChild(labelDiv);
        }
        // Render the prompt text below the label/image
        const promptText = document.createElement('p');
        promptText.className = 'geems-image-prompt'; // Specific class for prompt text styling
        promptText.textContent = `Prompt: ${imagePrompt}`;
        wrapper.appendChild(promptText);
    }

    /**
     * Renders a text element, handling labels and basic Markdown.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderText(wrapper, element, adjustedColor) {
        const textContent = element.text || element.value || '';
        // Determine if a label should be shown (exclude specific named text elements)
        const useLabel = element.label && !['narrative', 'divine_wisdom', 'player_facing_analysis', 'gemini_facing_analysis'].some(namePart => element.name?.includes(namePart));

        if (useLabel) {
            const label = document.createElement('label');
            label.className = 'geems-label';
            if (adjustedColor) label.style.color = adjustedColor;
            label.textContent = element.label;
            wrapper.appendChild(label);
        }
        const textElement = document.createElement('div');
        textElement.className = 'geems-text';
        // Basic Markdown parsing (bold, italics, code blocks, newlines)
        textElement.innerHTML = textContent
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
            .replace(/\*(.*?)\*/g, '<em>$1</em>')       // Italics
            .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre>${p1.trim().replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`) // Code blocks
            .replace(/\n/g, '<br>'); // Newlines
        wrapper.appendChild(textElement);
    }

    /**
     * Renders a text field (textarea) element.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderTextField(wrapper, element, adjustedColor) {
        const label = document.createElement('label');
        label.className = 'geems-label';
        label.textContent = element.label || element.name; // Use name as fallback label
        label.htmlFor = element.name; // Associate label with input
        if (adjustedColor) label.style.color = adjustedColor;
        wrapper.appendChild(label);

        const input = document.createElement('textarea');
        input.className = 'geems-textarea'; // Use specific class for textarea styling
        input.id = element.name;
        input.name = element.name;
        input.rows = 4; // Default rows
        input.value = element.value || ''; // Pre-fill value if provided
        input.placeholder = element.placeholder || 'Type your response here...';
        input.dataset.elementType = 'textfield'; // Mark element type for collection
        wrapper.appendChild(input);
    }

    /**
     * Renders a checkbox element.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderCheckbox(wrapper, element, adjustedColor) {
        const optionDiv = document.createElement('div');
        optionDiv.className = 'geems-checkbox-option'; // Use specific class for checkbox option styling

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = element.name;
        input.name = element.name;
        // Check based on boolean true or string 'true'
        input.checked = element.value === true || String(element.value).toLowerCase() === 'true';
        input.dataset.elementType = 'checkbox'; // Mark element type
        if (adjustedColor) input.style.accentColor = adjustedColor; // Style checkbox color

        const label = document.createElement('label');
        label.htmlFor = element.name;
        label.textContent = element.label || element.name; // Use name as fallback label
        if (adjustedColor) label.style.color = adjustedColor;
        label.className = "ml-2 flex-grow cursor-pointer"; // Styling for label

        optionDiv.appendChild(input);
        optionDiv.appendChild(label);
        wrapper.appendChild(optionDiv); // Append the whole option div to the main wrapper
    }

    /**
     * Renders a slider (range input) element.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderSlider(wrapper, element, adjustedColor) {
        const label = document.createElement('label');
        label.className = 'geems-label';
        label.textContent = element.label || element.name; // Use name as fallback label
        label.htmlFor = element.name;
        if (adjustedColor) label.style.color = adjustedColor;
        wrapper.appendChild(label);

        const sliderContainer = document.createElement('div');
        sliderContainer.className = 'flex items-center space-x-4 mt-2'; // Layout for slider and value

        const input = document.createElement('input');
        input.type = 'range';
        input.className = 'geems-slider flex-grow'; // Use specific class for slider styling
        input.id = element.name;
        input.name = element.name;
        const min = parseFloat(element.min) || 0; // Default min 0
        const max = parseFloat(element.max) || 10; // Default max 10
        input.min = min;
        input.max = max;
        input.step = element.step || 1; // Default step 1
        // Pre-fill value, ensuring it's within min/max bounds, default to midpoint if invalid
        const defaultValue = parseFloat(element.value);
        input.value = isNaN(defaultValue) ? (min + max) / 2 : Math.max(min, Math.min(max, defaultValue));
        input.dataset.elementType = 'slider'; // Mark element type
        // Apply adjusted color to slider thumb/track
        if (adjustedColor) {
            input.style.accentColor = adjustedColor;
            // Custom property for thumb color (might need browser-specific prefixes in real CSS)
            input.style.setProperty('--slider-thumb-color', adjustedColor);
            // Ensure style attribute exists before appending
            input.setAttribute('style', `${input.getAttribute('style') || ''} --slider-thumb-color: ${adjustedColor};`);
        }

        const valueDisplay = document.createElement('span');
        valueDisplay.className = `geems-slider-value-display font-medium w-12 text-right`; // Styling for value display
        valueDisplay.textContent = input.value; // Show initial value
        if (adjustedColor) valueDisplay.style.color = adjustedColor;

        // Update value display on slider input
        input.oninput = () => {
            valueDisplay.textContent = input.value;
        };

        sliderContainer.appendChild(input);
        sliderContainer.appendChild(valueDisplay);
        wrapper.appendChild(sliderContainer); // Append the container to the main wrapper
    }

    /**
     * Renders a radio button group element.
     * Handles options provided as JSON string array or single string.
     * @param {HTMLElement} wrapper - The container div for the element.
     * @param {object} element - The UI element definition.
     * @param {string|null} adjustedColor - The contrast-adjusted color.
     */
    function renderRadio(wrapper, element, adjustedColor) {
        const label = document.createElement('label');
        label.className = 'geems-label';
        label.textContent = element.label || element.name; // Use name as fallback label
        if (adjustedColor) label.style.color = adjustedColor;
        wrapper.appendChild(label);

        let options = [];
        let defaultValue = null;
        // Options can be in element.options or element.value
        let optionsSource = element.options || element.value;

        try {
            // If optionsSource is a string, try parsing it as JSON array
            if (typeof optionsSource === 'string') {
                try {
                    optionsSource = JSON.parse(optionsSource);
                } catch (e) {
                    // If parsing fails, treat the string as a single option
                    optionsSource = [{label: optionsSource, value: optionsSource}];
                    console.warn(`Radio options for '${element.name}' was a string, treating as single option:`, optionsSource);
                }
            }

            // Process if optionsSource is now an array
            if (Array.isArray(optionsSource)) {
                options = optionsSource.map(opt => {
                    let currentLabel = '', currentValue = '', isDefault = false;
                    // Handle object format {label: "...", value: "..."}
                    if (typeof opt === 'object' && opt !== null && opt.value !== undefined) {
                        currentValue = String(opt.value);
                        currentLabel = opt.label !== undefined ? String(opt.label) : currentValue; // Use value if label missing
                        // Check for '*' prefix indicating default
                        if (currentLabel.startsWith('*')) {
                            defaultValue = currentValue;
                            currentLabel = currentLabel.substring(1); // Remove '*' from label
                            isDefault = true;
                        }
                    }
                    // Handle simple string format "Option" or "*Default Option"
                    else {
                        currentValue = String(opt);
                        currentLabel = currentValue;
                        // Check for '*' prefix indicating default
                        if (currentLabel.startsWith('*')) {
                            defaultValue = currentValue.substring(1); // Remove '*' from value and label
                            currentValue = defaultValue;
                            currentLabel = defaultValue;
                            isDefault = true;
                        }
                    }
                    return {value: currentValue, label: currentLabel, isDefault: isDefault};
                }).filter(opt => opt !== null); // Filter out any potential nulls

                // If no default was marked with '*', check if element.value matches an option value
                if (defaultValue === null && element.value && typeof element.value === 'string') {
                    // Avoid trying to parse element.value if it was already the source of options
                    let isValueSimpleString = true;
                    try {
                        if (Array.isArray(JSON.parse(element.value))) isValueSimpleString = false;
                    } catch (e) { /* ignore parse error */
                    }

                    if (isValueSimpleString) {
                        const directValueMatch = options.find(opt => opt.value === element.value);
                        if (directValueMatch) {
                            defaultValue = directValueMatch.value; // Set default based on element.value match
                        }
                    }
                }

            } else {
                console.warn("Unexpected format for radio options:", element.name, optionsSource);
            }
        } catch (e) {
            console.error("Failed to process radio options:", element.name, e);
        }

        // If still no default, and options exist, pick the first one
        if (defaultValue === null && options.length > 0) {
            defaultValue = options[0].value;
        }

        // Render each radio button option
        if (options.length > 0) {
            options.forEach((option, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'geems-radio-option'; // Use specific class for radio option styling

                const input = document.createElement('input');
                input.type = 'radio';
                const inputId = `${element.name}_${index}`; // Unique ID for each radio input
                input.id = inputId;
                input.name = element.name; // All radios in group share the same name
                input.value = option.value;
                input.checked = (option.value === defaultValue); // Check if this is the default
                input.dataset.elementType = 'radio'; // Mark element type
                if (adjustedColor) input.style.accentColor = adjustedColor; // Style radio button color

                const optionLabel = document.createElement('label');
                optionLabel.htmlFor = inputId; // Associate label with input
                optionLabel.textContent = option.label;
                if (adjustedColor) optionLabel.style.color = adjustedColor;
                optionLabel.className = "ml-2 flex-grow cursor-pointer"; // Styling for label

                optionDiv.appendChild(input);
                optionDiv.appendChild(optionLabel);
                wrapper.appendChild(optionDiv); // Append the option div to the main wrapper
            });
        } else {
            // Show error if no valid options were found
            wrapper.innerHTML += `<p class="text-sm text-red-600">Error: No valid options found for radio group '${element.name}'.</p>`;
        }
    }

    /**
     * Renders a toggle container for player and Gemini analysis text.
     * @param {object} playerAnalysisElem - The player-facing analysis element definition.
     * @param {object} geminiAnalysisElem - The Gemini-facing analysis element definition.
     */
    function renderAnalysisToggle(playerAnalysisElem, geminiAnalysisElem) {
        const wrapper = document.createElement('div');
        wrapper.className = 'geems-element analysis-toggle-container'; // Specific class for toggle styling
        // Inherit voice class if present on Gemini analysis
        if (geminiAnalysisElem.voice) wrapper.classList.add(`voice-${geminiAnalysisElem.voice}`);

        // Determine border color based on Gemini analysis color or default
        const rawColor = (geminiAnalysisElem.color && isValidHexColor(geminiAnalysisElem.color)) ? geminiAnalysisElem.color : '#10b981'; // Default green
        const borderColor = adjustColorForContrast(rawColor);
        wrapper.style.borderColor = borderColor; // Apply color to all borders of the toggle

        // Create div for player analysis (initially visible)
        const playerDiv = document.createElement('div');
        playerDiv.className = 'analysis-content player-analysis';
        playerDiv.style.display = 'block'; // Player analysis shown by default
        renderAnalysisContent(playerDiv, playerAnalysisElem, borderColor); // Render content inside

        // Create div for Gemini analysis (initially hidden)
        const geminiDiv = document.createElement('div');
        geminiDiv.className = 'analysis-content gemini-analysis';
        geminiDiv.style.display = 'none'; // Gemini analysis hidden by default
        renderAnalysisContent(geminiDiv, geminiAnalysisElem, borderColor); // Render content inside

        // Create toggle icon (using Lucide font class)
        const icon = document.createElement('i');
        icon.className = 'lucide lucide-repeat analysis-toggle-icon'; // Icon class
        // Set custom property for hover color if border color is valid
        if (borderColor) wrapper.style.setProperty('--toggle-hover-color', borderColor);

        // Append elements to wrapper
        wrapper.appendChild(playerDiv);
        wrapper.appendChild(geminiDiv);
        wrapper.appendChild(icon);

        // Add click listener to toggle visibility
        wrapper.addEventListener('click', (event) => {
            // Prevent toggling if click is inside a <pre> block (e.g., selecting text)
            if (event.target.closest('pre')) return;

            const isPlayerVisible = playerDiv.style.display !== 'none';
            playerDiv.style.display = isPlayerVisible ? 'none' : 'block'; // Toggle player div
            geminiDiv.style.display = isPlayerVisible ? 'block' : 'none'; // Toggle gemini div

            // Also toggle visibility of the associated tweet element
            const tweetWrapper = document.getElementById('tweet-element-wrapper');
            if (tweetWrapper) tweetWrapper.style.display = geminiDiv.style.display; // Match tweet visibility to Gemini analysis

            // Rotate icon based on which analysis is visible
            icon.style.transform = geminiDiv.style.display !== 'none' ? 'translateY(-50%) rotate(180deg)' : 'translateY(-50%) rotate(0deg)';
        });
        uiContainer.appendChild(wrapper); // Add the toggle container to the UI
    }

    /**
     * Renders the content (label and text) inside an analysis div.
     * @param {HTMLElement} containerDiv - The div to render content into (player or gemini).
     * @param {object} analysisElement - The analysis element definition.
     * @param {string} borderColor - The adjusted border color for styling.
     */
    function renderAnalysisContent(containerDiv, analysisElement, borderColor) {
        const textContent = analysisElement.text || analysisElement.value || '';
        // Render label if provided
        if (analysisElement.label) {
            const analysisLabel = document.createElement('div');
            analysisLabel.className = 'geems-label font-semibold mb-2'; // Analysis label styling
            if (borderColor) {
                analysisLabel.style.color = borderColor; // Use border color for label
                analysisLabel.style.borderBottomColor = borderColor; // Use border color for underline
            }
            analysisLabel.textContent = analysisElement.label;
            containerDiv.appendChild(analysisLabel);
        }
        // Render text content with basic Markdown
        const textElement = document.createElement('div');
        textElement.className = 'geems-text';
        textElement.innerHTML = textContent
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre>${p1.trim().replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`)
            .replace(/\n/g, '<br>');
        containerDiv.appendChild(textElement);
    }

    /**
     * Renders the hidden tweet element, initially hidden.
     * @param {object} tweetData - The hidden tweet element definition.
     */
    function renderTweetElement(tweetData) {
        const wrapper = document.createElement('div');
        wrapper.id = 'tweet-element-wrapper'; // ID for targeting
        wrapper.className = 'geems-element'; // Basic element styling
        wrapper.style.display = 'none'; // Initially hidden

        // Add a label for the tweet stream
        const label = document.createElement('div');
        label.className = 'geems-label';
        label.textContent = 'Gemini\'s Internal Tweet Stream:';
        wrapper.appendChild(label);

        // Add the tweet content
        const tweetContent = document.createElement('div');
        tweetContent.className = 'geems-text';
        tweetContent.textContent = tweetData.value || 'No tweet content.';
        wrapper.appendChild(tweetContent);

        // Try to insert the tweet element right after the analysis toggle container
        const analysisToggle = uiContainer.querySelector('.analysis-toggle-container');
        if (analysisToggle && analysisToggle.nextSibling) {
            // Insert before the element that is currently after the toggle
            uiContainer.insertBefore(wrapper, analysisToggle.nextSibling);
        } else if (analysisToggle) {
            // If toggle is the last element, append after it
            uiContainer.appendChild(wrapper);
        } else {
            // Fallback: Append after the last visible non-control element if toggle doesn't exist
            const lastVisibleElement = Array.from(uiContainer.children).reverse().find(el =>
                el.style.display !== 'none' &&
                !el.classList.contains('loading-indicator') &&
                !el.classList.contains('error-message') &&
                el.id !== 'submit-turn' // Exclude submit button itself
            );
            if (lastVisibleElement && lastVisibleElement.nextSibling) {
                uiContainer.insertBefore(wrapper, lastVisibleElement.nextSibling);
            } else {
                // If no suitable element found, just append to the end
                uiContainer.appendChild(wrapper);
            }
        }
    }


    // --- Utility Functions ---

    /** Collects the current state of all interactive UI elements. */
    function collectInputState() {
        const inputs = {};
        // Select all elements marked with 'data-element-type'
        uiContainer.querySelectorAll('[data-element-type]').forEach(el => {
            const name = el.name;
            if (!name) return; // Skip elements without a name
            const type = el.dataset.elementType;
            switch (type) {
                case 'textfield':
                    inputs[name] = el.value;
                    break;
                case 'checkbox':
                    inputs[name] = el.checked; // Store boolean value
                    break;
                case 'slider':
                    inputs[name] = parseFloat(el.value); // Store numeric value
                    break;
                case 'radio':
                    if (el.checked) { // Only store the value of the selected radio button
                        inputs[name] = el.value;
                    }
                    break;
            }
        });
        // Add the current turn number (based on history length before this turn)
        inputs['turn'] = historyQueue.length + 1;
        // console.log("Collected Inputs:", inputs);
        return JSON.stringify(inputs); // Return as JSON string
    }

    /** Sets the loading state for the UI. */
    function setLoading(loading) {
        isLoading = loading;
        loadingIndicator.style.display = loading ? 'flex' : 'none'; // Show/hide loading spinner

        // Determine if API key is present (needed for enabling submit button)
        const keyPresent = apiKeyInput.value.trim().length > 0;

        // Enable/disable main action buttons based on loading state and game state
        submitButton.disabled = loading || !(apiKeyLocked || keyPresent); // Submit enabled if not loading AND (game started OR key present)
        saveGameButton.disabled = loading || !apiKeyLocked; // Save enabled if not loading AND game started
        modeToggleButton.disabled = loading; // Mode toggle disabled during loading
        resetGameButton.disabled = loading || !apiKeyLocked; // Reset enabled if not loading AND game started

        // Disable/enable all interactive UI elements within the game container
        uiContainer.querySelectorAll('input, textarea, button, .analysis-toggle-container').forEach(el => {
            // Exclude the main footer buttons from this generic disabling logic
            if (el.id !== 'submit-turn' && el.id !== 'saveGameButton' && el.id !== 'modeToggleButton' && el.id !== 'resetGameButton') {
                // Disable form elements directly
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'BUTTON') {
                    el.disabled = loading;
                }
                // Dim and disable pointer events for custom styled elements
                if (el.classList.contains('geems-radio-option') || el.classList.contains('geems-checkbox-option') || el.classList.contains('geems-slider') || el.classList.contains('analysis-toggle-container')) {
                    el.style.opacity = loading ? 0.5 : 1.0;
                    el.style.pointerEvents = loading ? 'none' : 'auto';
                }
            }
        });
    }

    /** Displays an error message. */
    function showError(message) {
        errorDisplay.textContent = message;
        errorDisplay.style.display = 'block'; // Make error visible
    }

    /** Hides the error message. */
    function hideError() {
        errorDisplay.textContent = '';
        errorDisplay.style.display = 'none'; // Make error hidden
    }

    /** Checks if a string is a valid hex color code. */
    function isValidHexColor(hex) {
        return typeof hex === 'string' && /^#[0-9A-F]{6}$/i.test(hex);
    }

    /** Adjusts a hex color to ensure minimum lightness contrast against a light background. */
    function adjustColorForContrast(hex) {
        if (!isValidHexColor(hex)) return hex; // Return original if invalid

        // Convert hex to HSL
        let r = parseInt(hex.substring(1, 3), 16), g = parseInt(hex.substring(3, 5), 16),
            b = parseInt(hex.substring(5, 7), 16);
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2; // Calculate lightness

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min); // Calculate saturation
            switch (max) { // Calculate hue
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }

        // If lightness is too high (adjust MIN_CONTRAST_LIGHTNESS as needed)
        if (l > MIN_CONTRAST_LIGHTNESS) {
            l = MIN_CONTRAST_LIGHTNESS * 0.9; // Reduce lightness

            // Convert HSL back to RGB
            let r1, g1, b1;
            if (s === 0) {
                r1 = g1 = b1 = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r1 = hue2rgb(p, q, h + 1 / 3);
                g1 = hue2rgb(p, q, h);
                b1 = hue2rgb(p, q, h - 1 / 3);
            }

            // Convert RGB back to Hex
            const toHex = x => {
                const hexVal = Math.round(x * 255).toString(16);
                return hexVal.length === 1 ? '0' + hexVal : hexVal; // Pad with zero if needed
            };
            return `#${toHex(r1)}${toHex(g1)}${toHex(b1)}`;
        }
        return hex; // Return original hex if contrast is already sufficient
    }

    /** Displays a temporary message related to clipboard actions. */
    function showClipboardMessage(message, isError = false) {
        clipboardMessage.textContent = message;
        clipboardMessage.style.color = isError ? '#dc2626' : '#16a34a'; // Red for error, Green for success
        // Clear message after 3 seconds
        setTimeout(() => {
            clipboardMessage.textContent = '';
        }, 3000);
    }

    /** Updates the visual appearance and text of the mode toggle button. */
    function updateModeButtonVisuals() {
        if (isMasturbationMode) {
            modeToggleButton.textContent = 'Mode: Explicit';
            modeToggleButton.classList.remove('standard-mode'); // Remove green class
        } else {
            modeToggleButton.textContent = 'Mode: Standard';
            modeToggleButton.classList.add('standard-mode'); // Add green class
        }
    }

    /**
     * Sets the header, footer, and footer icon images using Pollinations AI with random seeds.
     * Includes nologo=true and safe=false parameters.
     */
    function setDynamicImages() {
        // Generate random seeds (0-65535)
        const headerSeed = Math.floor(Math.random() * 65536);
        const footerSeed = Math.floor(Math.random() * 65536);
        const iconSeed = Math.floor(Math.random() * 65536);

        // Define image prompts
        const headerPrompt = "wide cinematic vivid colorful abstract emotional landscape brainwaves";
        const footerPrompt = "wide abstract colorful digital roots network connections";
        const iconPrompt = "pixel art floppy disk";

        // Update Header Banner image source and alt text
        if (headerBanner) {
            headerBanner.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(headerPrompt)}?width=1200&height=200&seed=${headerSeed}&nologo=true&safe=false`;
            headerBanner.alt = headerPrompt;
        }

        // Update Footer Banner image source and alt text
        if (footerBanner) {
            footerBanner.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(footerPrompt)}?width=1200&height=100&seed=${footerSeed}&nologo=true&safe=false`;
            footerBanner.alt = footerPrompt;
        }

        // Update Footer Icon image source and alt text
        if (footerIconImage) {
            footerIconImage.src = `https://image.pollinations.ai/prompt/${encodeURIComponent(iconPrompt)}?width=60&height=60&seed=${iconSeed}&nologo=true&safe=false`;
            footerIconImage.alt = iconPrompt;
        }
    }

    // --- Event Listeners ---

    /** Handles the click event for the Submit Turn button. */
    submitButton.addEventListener('click', () => {
        console.log("Submit button clicked.");
        // Attempt to initialize/resume audio context on user interaction
        initAudioContext();
        if (isLoading) return; // Prevent multiple submissions while loading
        fetchTurnData(collectInputState()); // Fetch next turn data using current input state
    });

    /** Handles input changes in the API Key field. */
    apiKeyInput.addEventListener('input', () => {
        const keyPresent = apiKeyInput.value.trim().length > 0;
        // Enable/disable submit button based on key presence (if game not started)
        submitButton.disabled = isLoading || !(apiKeyLocked || keyPresent);
        // Enable/disable reset button similarly
        resetGameButton.disabled = isLoading || !(apiKeyLocked || keyPresent);

        // Update initial message if API key section is visible
        if (apiKeySection.style.display !== 'none') {
            const currentInitialMessage = document.getElementById('initial-message');
            if (keyPresent) {
                hideError(); // Hide any previous errors
                if (currentInitialMessage && currentInitialMessage.style.display !== 'none') {
                    currentInitialMessage.textContent = 'API Key entered. Click "Submit Turn" to begin your journey!';
                }
            } else {
                // Restore default initial message if key is removed
                if (currentInitialMessage) {
                    currentInitialMessage.innerHTML = 'Enter your API Key above (or provide in URL) and click "Submit Turn" to start.<br>Or, paste previously saved game code into your browser console to load a game.';
                    currentInitialMessage.style.display = 'block';
                }
            }
        }
    });

    /** Handles the click event for the Save Game button. */
    saveGameButton.addEventListener('click', () => {
        console.log("Save Game button clicked (Manual Save).");
        // Ensure game has started and state exists
        if (!apiKeyLocked || !currentUiJson || !historyQueue) {
            showClipboardMessage("Cannot save: Game not started or state missing.", true);
            return;
        }
        // Ensure API key is present
        const rawApiKey = apiKeyInput.value.trim();
        if (!rawApiKey) {
            showClipboardMessage("Cannot save: API Key is missing.", true);
            return;
        }

        // Get current game URL
        const gameUrl = window.location.origin + window.location.pathname;

        // Prepare state object for manual save (includes URL)
        const stateToSaveForManual = {
            encodedApiKey: encodeApiKey(rawApiKey),
            currentUiJson: currentUiJson,
            historyQueue: historyQueue,
            isMasturbationMode: isMasturbationMode,
            currentModelIndex: currentModelIndex,
            gameUrl: gameUrl // Include URL for potential navigation during restore
        };

        let stateJsonString;
        try {
            stateJsonString = JSON.stringify(stateToSaveForManual);
        } catch (e) {
            console.error("Error stringifying game state for manual saving:", e);
            showClipboardMessage("Error preparing game state for manual saving.", true);
            return;
        }

        // Create the self-executing restoration code to be copied
        const restorationLoaderCode = `
(function() {
    console.log("GEEMS Restoration Loader: Storing state and checking URL...");
    try {
        const stateToStore = ${stateJsonString}; // Embed the saved state JSON
        const storageKey = '${LOCAL_STORAGE_KEY}'; // Use the game's storage key
        const currentGameUrl = window.location.origin + window.location.pathname;

        // Store the state in localStorage
        localStorage.setItem(storageKey, JSON.stringify(stateToStore));
        console.log("Saved state stored in localStorage under key:", storageKey);

        // Check if the current URL matches the saved URL
        if (currentGameUrl !== stateToStore.gameUrl) {
            // If URLs don't match, navigate to the correct URL
            console.log("Current URL (" + currentGameUrl + ") does not match saved URL (" + stateToStore.gameUrl + "). Navigating...");
            alert("GEEMS state saved to browser storage. Navigating to the correct game page to restore..."); // Use alert for user feedback
            window.location.href = stateToStore.gameUrl; // Redirect
        } else {
            // If URLs match, simply reload the page to trigger the restore logic
            console.log("Already on the correct game URL. Reloading page to apply stored state...");
            alert("GEEMS state saved to browser storage. Reloading page to restore..."); // Use alert for user feedback
            window.location.reload(); // Reload
        }

    } catch (error) {
        console.error("Error in GEEMS Restoration Loader:", error);
        alert("Error preparing game state restoration: " + error.message + "\\nCheck the console for more details."); // Use alert for error feedback
        localStorage.removeItem('${LOCAL_STORAGE_KEY}'); // Clear potentially bad state on error
    }
})();
        `;

        // Attempt to copy the restoration code to the clipboard
        navigator.clipboard.writeText(restorationLoaderCode).then(() => {
            console.log("Restoration loader code copied to clipboard.");
            showClipboardMessage("Save code copied! Paste into console to restore."); // Success message
        }).catch(err => {
            // Handle clipboard write failure (e.g., permissions, browser support)
            console.error('Failed to copy restoration loader code: ', err);
            showClipboardMessage("Failed to copy code. See console.", true); // Error message
            // Log the code to the console as a fallback
            console.log("--- GEEMS Save State Loader Code (Copy Manually) ---");
            console.log(restorationLoaderCode);
            console.log("--- End GEEMS Save State Loader Code ---");
            showClipboardMessage("Copy failed. Loader code logged to console.", true); // Update message
        });
    });

    /** Handles the click event for the Mode Toggle button. */
    modeToggleButton.addEventListener('click', () => {
        if (isLoading) return; // Prevent toggling while loading
        isMasturbationMode = !isMasturbationMode; // Flip the mode flag
        console.log(`Masturbation Mode Toggled: ${isMasturbationMode}`);
        updateModeButtonVisuals(); // Update button appearance
        // Auto-save state when mode changes, as it's a significant state change
        autoSaveGameState();
    });

    /** Handles the click event for the Reset Game button. */
    resetGameButton.addEventListener('click', () => {
        // Prevent reset if loading or game hasn't started
        if (isLoading || !apiKeyLocked) return;

        // Confirm with the user before resetting
        if (confirm('Are you sure you want to reset the game? All progress will be lost.')) {
            console.log("Resetting game state...");

            // Clear core game state variables
            historyQueue = [];
            currentUiJson = null;
            currentNotes = {};
            currentSubjectId = "";
            isMasturbationMode = true; // Reset to default mode
            currentModelIndex = 0; // Reset to first model

            // Clear game state from localStorage
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            console.log("Cleared game state from localStorage.");

            // Reset UI and errors
            uiContainer.innerHTML = ''; // Clear game elements
            hideError(); // Hide any existing errors

            // Re-add initial message temporarily (will be hidden/updated by fetchTurnData)
            let currentInitialMessage = document.getElementById('initial-message');
            if (!currentInitialMessage) {
                // If it was removed entirely, recreate it
                currentInitialMessage = document.createElement('div');
                currentInitialMessage.id = 'initial-message';
                currentInitialMessage.className = 'text-center text-gray-500 p-6 bg-white rounded-lg shadow';
                uiContainer.appendChild(currentInitialMessage);
            }
            currentInitialMessage.style.display = 'block'; // Ensure it's visible
            currentInitialMessage.innerHTML = 'Resetting game... Loading first turn.'; // Indicate reset


            // Update button states
            submitButton.disabled = false; // Submit should be enabled as API key is still considered valid
            saveGameButton.disabled = true; // Disable save until first turn is generated
            resetGameButton.disabled = false; // Keep reset enabled (since key is still valid)
            updateModeButtonVisuals(); // Update mode button text to default

            // Fetch the very first turn again (will set loading state)
            // Send empty JSON "{}" as player actions for the first turn fetch
            fetchTurnData("{}");
            // Auto-save will happen automatically after T1 loads successfully
        }
    });


    // --- Initial Game Setup ---

    /** Initializes the game state. Checks localStorage, then URL param, then sets up for manual start. */
    function initializeGame() {
        console.log("Initializing GEEMS interface...");
        let autoStarted = false; // Flag to track if game loaded automatically

        // --- Priority 1: Load from localStorage (Auto-saved or Manually restored state) ---
        const storedStateString = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedStateString) {
            console.log("Found saved state in localStorage. Attempting restore...");
            let savedState;
            try {
                savedState = JSON.parse(storedStateString);
                // NOTE: State is NOT removed from localStorage here. It persists until reset or error.

                // Decode API key
                const decodedApiKey = decodeApiKey(savedState.encodedApiKey);
                if (!decodedApiKey) {
                    throw new Error("Failed to decode API key from saved state.");
                }

                // Restore game state variables
                apiKeyInput.value = decodedApiKey;
                historyQueue = savedState.historyQueue || [];
                currentUiJson = savedState.currentUiJson || null;
                isMasturbationMode = savedState.isMasturbationMode === true; // Default to true if undefined/false
                currentModelIndex = savedState.currentModelIndex || 0;
                apiKeyLocked = true; // Assume key is locked if state is restored
                autoStarted = true; // Mark as auto-started

                console.log("State restored from localStorage:", {
                    historyLength: historyQueue.length,
                    mode: isMasturbationMode,
                    modelIndex: currentModelIndex
                });

                setDynamicImages(); // Set header/footer images

                // Render the restored UI if it exists
                if (currentUiJson) {
                    renderUI(currentUiJson);
                } else {
                    // If UI data is missing, treat as error, clear storage, force manual start
                    console.warn("Restored state missing UI data. Clearing storage and forcing manual start.");
                    localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear bad state
                    throw new Error("Restored state was incomplete (missing UI)."); // Trigger catch block
                }

                // Update UI elements post-restore
                updateModeButtonVisuals();
                apiKeySection.style.display = 'none'; // Hide API key section
                const currentInitialMessage = document.getElementById('initial-message');
                if (currentInitialMessage) currentInitialMessage.style.display = 'none'; // Hide initial message
                hideError(); // Clear any previous errors
                setLoading(false); // Ensure loading indicator is off
                // Enable appropriate buttons
                submitButton.disabled = false;
                saveGameButton.disabled = false;
                resetGameButton.disabled = false;
                modeToggleButton.disabled = false;

                // Optional: Briefly show restore success message (uncomment if desired)
                // showClipboardMessage("Game state restored successfully!", false);

            } catch (error) {
                // Handle errors during restore
                console.error("Error restoring state from localStorage:", error);
                showError(`Error restoring saved state: ${error.message}. Please start manually.`);
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear corrupted/incomplete state

                // Reset state variables to ensure a clean manual start
                historyQueue = [];
                currentUiJson = null;
                isMasturbationMode = true;
                currentModelIndex = 0;
                apiKeyLocked = false;
                autoStarted = false; // Ensure manual start proceeds
                apiKeyInput.value = ''; // Clear API key field

                // Reset UI for manual start
                uiContainer.innerHTML = ''; // Clear potentially broken UI
                const initialMsg = document.getElementById('initial-message');
                if (initialMsg) {
                    initialMsg.style.display = 'block'; // Show initial message
                    initialMsg.innerHTML = 'Error restoring state. Enter your API Key above (or provide in URL) and click "Submit Turn" to start.<br>Or, paste previously saved game code into your browser console to load a game.';
                }
                if (apiKeySection) apiKeySection.style.display = 'block'; // Show API key section
                // Disable buttons appropriately for manual start
                submitButton.disabled = true;
                saveGameButton.disabled = true;
                resetGameButton.disabled = true;
                setDynamicImages(); // Set default images
            }
        }

        // --- Priority 2: Load from 'apiKey' URL parameter (only if not loaded from storage) ---
        if (!autoStarted) {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const keyFromUrlParam = urlParams.get('apiKey');

                if (keyFromUrlParam) {
                    console.log("API Key found in URL parameter. Attempting auto-start...");
                    apiKeyInput.value = keyFromUrlParam; // Set API key from URL
                    apiKeyLocked = false; // Key is present but not locked until first fetch succeeds
                    // Reset other state variables for a fresh start
                    currentModelIndex = 0;
                    isMasturbationMode = true; // Default mode
                    historyQueue = [];
                    currentUiJson = null;

                    // Update UI for auto-start
                    apiKeySection.style.display = 'none'; // Hide API key section
                    const currentInitialMessage = document.getElementById('initial-message');
                    if (currentInitialMessage) currentInitialMessage.style.display = 'none'; // Hide initial message
                    submitButton.disabled = false; // Enable submit immediately
                    updateModeButtonVisuals();
                    modeToggleButton.disabled = false;
                    saveGameButton.disabled = true; // Disabled until game starts properly
                    resetGameButton.disabled = true; // Disabled until game starts properly

                    // Clean the API key from the URL bar for security/cleanliness
                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.delete('apiKey');
                    window.history.replaceState(null, '', currentUrl.toString()); // Update URL without reloading

                    setDynamicImages(); // Set header/footer images
                    // Fetch the first turn using the provided key
                    fetchTurnData("{}"); // Send empty actions for first turn
                    autoStarted = true; // Mark as auto-started
                }
            } catch (e) {
                console.error("Error processing URL parameters:", e);
                showError("Error reading URL parameters. Please start manually.");
                autoStarted = false; // Ensure manual start proceeds if URL processing fails
            }
        }

        // --- Manual Start Setup (if not auto-started from storage or URL) ---
        if (!autoStarted) {
            console.log("Manual start required. Enter API Key or paste save code into console.");
            // Ensure state variables are reset for a clean manual start
            historyQueue = [];
            currentUiJson = null;
            isMasturbationMode = true;
            currentModelIndex = 0;
            apiKeyLocked = false;
            uiContainer.innerHTML = ''; // Clear UI container

            // Ensure initial message is displayed correctly
            let currentInitialMessage = document.getElementById('initial-message');
            if (!currentInitialMessage) {
                // Recreate if missing
                console.log("Recreating initial-message element for manual start.");
                currentInitialMessage = document.createElement('div');
                currentInitialMessage.id = 'initial-message';
                currentInitialMessage.className = 'text-center text-gray-500 p-6 bg-white rounded-lg shadow';
                uiContainer.appendChild(currentInitialMessage);
            }
            currentInitialMessage.style.display = 'block'; // Make sure it's visible
            currentInitialMessage.innerHTML = 'Enter your API Key above (or provide in URL) and click "Submit Turn" to start.<br>Or, paste previously saved game code into your browser console to load a game.';

            // Ensure API key section is visible and input is clear
            if (apiKeySection) apiKeySection.style.display = 'block';
            apiKeyInput.value = '';

            // Set initial button states for manual start
            setLoading(false); // Ensure loading indicator is off
            hideError(); // Clear any previous errors
            submitButton.disabled = true; // Disabled until API key is entered
            saveGameButton.disabled = true; // Disabled until game starts
            resetGameButton.disabled = true; // Disabled until game starts
            modeToggleButton.disabled = false; // Mode can be toggled before start
            updateModeButtonVisuals(); // Set initial mode button text
            setDynamicImages(); // Set header/footer images
        }
    }

    // --- Initialize ---
    // Call the initialization function when the script loads
    initializeGame();

</script>

</body>
</html>
